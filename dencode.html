<html>

<head>
    <title>DENCODER</title>
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2aWV3Qm94PSIxMjQuODkyIDE0NC43MDcgMjAwLjMxIDEwNi4wMDkiIHdpZHRoPSIyMDAuMzEiIGhlaWdodD0iMTA2LjAwOSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczpieD0iaHR0cHM6Ly9ydWlwZWRyb2xvcGVzLmdpdGh1Yi5pbyI+CiAgPGcgc3R5bGU9IiIgdHJhbnNmb3JtPSJtYXRyaXgoMC44NDMxMDksIC0wLjAzNzU3MywgMCwgMS4yMTgwNjgsIDE5LjU5NDQyNSwgLTQzLjUzMTk1NikiPgogICAgPGcgc3R5bGU9IiIgdHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMS4zMjE2NzUsIC05NC4zMzU1MjYsIDc2LjA0NDU3MSkiPgogICAgICA8cmVjdCB4PSIyNDguNzkxIiB5PSI5NC43MTEiIHdpZHRoPSIxNTAuODUyIiBoZWlnaHQ9IjEwLjI3IiBzdHlsZT0ic3Ryb2tlOiByZ2IoMCwgMCwgMCk7IHN0cm9rZS13aWR0aDogMHB4OyBmaWxsOiByZ2IoMjU1LCAyNTUsIDApOyIgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTk5OSwgLTAuMDA0NDc5LCAtMC40MzQzOTMsIDEuMDAxOTU2LCAxNi4wNDIxMTIsIDEwLjQ0OTM0MykiLz4KICAgICAgPHBhdGggZD0iTSAzNjYuMzYzIDM4LjIyNSBMIDM5My4wNTUgMTIwLjA0OSBMIDM2Ni4zNjMgMTIwLjA0OSBMIDM2Ni4zNjMgMzguMjI1IFoiIHN0eWxlPSJzdHJva2U6IHJnYigwLCAwLCAwKTsgc3Ryb2tlLXdpZHRoOiAwcHg7IGZpbGw6IHJnYigyNTUsIDI1NSwgMCk7IiB0cmFuc2Zvcm09Im1hdHJpeCgtMC4zODM5MjYsIDAuOTIzMzY0LCAtMS4wOTI5NjksIDAuMDIzOTg0LCA2MzIuODk0MTA0LCAtMjM3LjY1ODk2NikiIGJ4OnNoYXBlPSJ0cmlhbmdsZSAzNjYuMzYzIDM4LjIyNSAyNi42OTIgODEuODI0IDAgMCAxQDhhMzNkY2U1Ii8+CiAgICA8L2c+CiAgICA8ZyBzdHlsZT0iIiB0cmFuc2Zvcm09Im1hdHJpeCgtMSwgMCwgMCwgLTEuMzIxNjc4LCA1ODEuNzA0NTI5LCAzMzUuMDk3MDQ2KSI+CiAgICAgIDxyZWN0IHg9IjI0OC43OTEiIHk9Ijk0LjcxMSIgd2lkdGg9IjE1MC44NTIiIGhlaWdodD0iMTAuMjciIHN0eWxlPSJzdHJva2U6IHJnYigwLCAwLCAwKTsgc3Ryb2tlLXdpZHRoOiAwcHg7IGZpbGw6IHJnYigwLCAxNzQsIDI1NSk7IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTk5LCAtMC4wMDQ0NzksIC0wLjQzNDM5MywgMS4wMDE5NTYsIDE2LjA0MjExMiwgMTAuNDQ5MzQzKSIvPgogICAgICA8cGF0aCBkPSJNIDM2Ni4zNjMgMzguMjI1IEwgMzkzLjA1NSAxMjAuMDQ5IEwgMzY2LjM2MyAxMjAuMDQ5IEwgMzY2LjM2MyAzOC4yMjUgWiIgc3R5bGU9InN0cm9rZTogcmdiKDAsIDAsIDApOyBzdHJva2Utd2lkdGg6IDBweDsgZmlsbDogcmdiKDAsIDE3NCwgMjU1KTsiIHRyYW5zZm9ybT0ibWF0cml4KC0wLjM4MzkyNiwgMC45MjMzNjQsIC0xLjA5Mjk2OSwgMC4wMjM5ODQsIDYzMi44OTQxMDQsIC0yMzcuNjU4OTY2KSIgYng6c2hhcGU9InRyaWFuZ2xlIDM2Ni4zNjMgMzguMjI1IDI2LjY5MiA4MS44MjQgMCAwIDFAOGEzM2RjZTUiLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPg==">
    <meta charset="UTF-8"/>
    <!-- General -->
    <style>
        body {
            margin: 20px;
            font-family: sans-serif;
            background-color: #353535;
            color: silver;
        }

        input {
            background-color: darkgray;
            border-radius: 4pt
        }

        textarea {
            width: 100%;
            height: 50%;
            max-width: 100%;
            background-color: rgb(36, 36, 36);
            color: silver;
            caret-color: orange;
        }

        textarea::selection {
            color: #101010;
            background-color: darkgray;
        }

        .buttonGroup,
        .checkAlign {
            display: inline-block;
            vertical-align: top;
        }

        .settingsGroup {
            padding-left: 5px;
        }
        
        .settingsGroup>label {
            line-height: 30px;
        }

        .buttonGroup>label {
            user-select: none;
        }

        input[type=checkbox] {
            margin: revert;
        }

        input[type=text], input[type=number], input[type=password] {
            font-family: monospace;
            background-color: rgb(36, 36, 36);
            color: silver;
            margin: revert;
        }

        input[type=number] {
            width: 50px;
        }

        input[type=range] {
            margin: revert;
        }

        .historyItem {
            height: 100px;
            font-size: small;
            border-bottom: solid 3px;
            overflow: hidden;
            white-space: nowrap;
            background-color: #242424;
            color: #ccc;
            font-family: monospace;
            user-select: none;
            padding: 2px;
        }

        .sidebar {
            position: absolute; top: 0px; bottom: 0px; right: 0px;
        }

        .sidebarExpanded {
            right: 203px;
        }

        .sidebarExpanded .sidebarBody {
            display: block !important;
        }

        .sidebar .sidebarBody {
            position: absolute;
            top: 0px;
            left: 20px;
            width: 200px;
            background-color: #ccc;
            bottom: 0px;
            border-left: solid 3px;
            overflow-y: auto;
            display: none;
        }

        hr {
            margin-top: 0.2rem;
            margin-bottom: 0.2rem;
        }

        .nowrap {
            overflow-wrap: anywhere;
            white-space: nowrap;
        }

    </style>
    <!-- Controls -->
    <style>
        .switch {
            color: black;
            position: relative;
            display: inline-block;
            width: 120px;
            height: 30px;
            font-size: 14px;
            font-weight: 500;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
            margin-top: 16px;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
            text-align: center;
        }

        .slider-copy:after {
            content: "Transform";
        }

        input:checked+.slider-copy:after {
            content: "Copy";
        }

        .slider-padding:after {
            content: "Spaces";
        }

        input:checked+.slider-padding:after {
            content: "Tabs";
        }

        .slider-selection:after {
            content: "All text";
        }

        input:checked+.slider-selection:after {
            content: "Selection";
        }
        
        .slider-sort:after {
            content: "Asc.";
        }

        input:checked+.slider-sort:after {
            content: "Desc.";
        }

        .slider-wrap:after {
            content: "Wrap";
        }

        input:checked+.slider-wrap:after {
            content: "No wrap";
        }

        .slider:after {
            line-height: 30px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            box-shadow: 2px 2px 8px 1px #434343ba
        }

        input:checked+.slider {
            background-color: #2196F3;
        }

        input:focus+.slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked+.slider:before {
            -webkit-transform: translateX(90px);
            -ms-transform: translateX(90px);
            transform: translateX(90px);
        }

        /* Rounded sliders */
        .slider.round {
            border-radius: 30px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        .button {
            background-color: #ccc;
            border: 2px solid #7c7c7c;
            color: #000000;
            padding: 6px 22px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 4px 2px;
            transition-duration: 0.4s;
            cursor: pointer;
            border-radius: 8px;
            width: 100%;
        }

        .button:hover {
            background-color: #4d4d4d;
            border: 2px solid #c5c5c5;
            color: white;
        }

        .button:active {
            background-color: #2196F3;
            border: 2px solid #7c7c7c;
            color: #000000;
        }

        .button-xsmall {
            padding: 2px 6px;
            font-size: 14px;
        }

        .button.round {
            text-align: left;
            margin: 0;
            padding: 5px 22px;
            border-radius: 30px;
            font-size: 14px;
        }

        select:active {
            background-color: unset !important;
        }

        select:hover {
            background-color: #ccc !important;
            color: #000000 !important;
        }

        .off-on {
            width: 40px;
            height: 20px;
            position: relative;
            display: inline-block;
            margin: 5px 0;
        }

        .off-on-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            -webkit-transition: .4s;
            transition: .4s;
        }

        .off-on input {
            opacity: 0;
            width: 0;
            height: 0;
            margin-top: 16px;
        }

        .off-on-slider:after {
            line-height: 20px;
        }

        .off-on-slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            -webkit-transition: .4s;
            transition: .4s;
            box-shadow: 1px 1px 3px 1px #434343ba
        }

        input:checked+.off-on-slider {
            background-color: #2196F3;
        }

        input:focus+.off-on-slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked+.off-on-slider:before {
            -webkit-transform: translateX(20px);
            -ms-transform: translateX(20px);
            transform: translateX(20px);
        }

        .off-on-slider.round {
            border-radius: 10px;
        }

        .off-on-slider.round:before {
            border-radius: 50%;
        }

        .off-on+label {
            cursor: pointer;
            user-select: none;
        }

        .off-on+label:before {
            content: " ";
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 7px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 5px;
            background-image: linear-gradient(#2196F3, #2196F3);
            background-repeat: no-repeat;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 15px;
            width: 15px;
            border-radius: 50%;
            background: #2196F3;
            cursor: ew-resize;
            box-shadow: 0 0 3px 0 #555;
            transition: background .3s ease-in-out;
        }

        input[type="range"]::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 15px;
            width: 15px;
            border-radius: 50%;
            background: #2196F3;
            cursor: ew-resize;
            box-shadow: 0 0 3px 0 #555;
            transition: background .3s ease-in-out;
        }

        input[type="range"]::-ms-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 15px;
            width: 15px;
            border-radius: 50%;
            background: #2196F3;
            cursor: ew-resize;
            box-shadow: 0 0 3px 0 #555;
            transition: background .3s ease-in-out;
        }

        input[type=range]::-webkit-slider-runnable-track {
            -webkit-appearance: none;
            box-shadow: none;
            border: none;
            background: transparent;
        }

        input[type=range]::-moz-range-track {
            -webkit-appearance: none;
            appearance: none;
            box-shadow: none;
            border: none;
            background: transparent;
        }

        input[type=range]::-ms-track {
            -webkit-appearance: none;
            appearance: none;
            box-shadow: none;
            border: none;
            background: transparent;
        }

        .success-tag {
            font-family: 'Courier New', Courier, monospace;
            background-color: greenyellow;
            color: black;
            font-weight: 600;
            padding: 0.1rem;
            border-radius: 0.2rem;
        }

        .error-tag {
            font-family: 'Courier New', Courier, monospace;
            background-color: tomato;
            color: black;
            font-weight: 600;
            padding: 0.1rem;
            border-radius: 0.2rem;
        }

    </style>
    <script type="text/javascript">

        window.onload = function () {
            const valueTextArea = getValueElement();
            valueTextArea.onmouseup =
            valueTextArea.onkeyup =
            valueTextArea.ontouchend =
            valueTextArea.onselect =
            valueTextArea.onselectionchange =
            valueTextArea.oninput =
            valueTextArea.onmouseleave = fetchData;
            
            document.getElementById("rndSpecialChars").onkeydown = preventInvalidSpecialChars;
            document.getElementById("rndStringLengthNumberInput").oninput = preventInvalidRndLength;

            adjustRndStringSlider(document.getElementById("rndStringLength"));

            initHistory();

            window.setInterval(() => {
                //if not modified in the last 2 seconds return
                if (new Date().getTime() - window.valueTouched.getTime() > 2000) {
                    return;
                }

                const detected = detectFormatOrLanguage();

                updateDetectedFormatDisplay(detected);
            }, 2000);
        }

        function isAsync(func) {
            return func.constructor.name === "AsyncFunction";
        }

        function getSelectionMode() {
            return document.getElementById("selectionMode").value;
        }

        async function transform(transformer, params) {
            if (typeof transformer != "function") {
                console.warn("Transformer is not a function.");
                return;
            }

            let fullValue = getValueElement().value;
            if (isSelectionMode()) {
                fullValue = fullValue.substr(cursorPos.start, cursorPos.end - cursorPos.start);
            }


            let values = [fullValue];
            if(getSelectionMode() === "lines") {
                values = fullValue.split("\n");
            }
            
            
            const finalResult = await Promise.all(values.map(async (value, index) => {
                try {
                    let result;

                    if(isAsync(transformer)) {
                        result = await transformer(value, params);
                    } else {
                        result = transformer(value, params);
                    }

                    if (typeof result != "string") {

                        // TODO evaluate if this can be deprecated
                        /*if (typeof result == "object" && typeof result.promise == "object" && typeof result.promise.then == "function") {
                            // this has a promise

                            result.promise.then((promiseResult) => {
                                addToHistory();
                                var b64result = auxiliary.arrayBufferToBase64(promiseResult);
                                
                                if(result.finalize) {
                                    displayResult(eval(result.finalize)(b64result));
                                } else {
                                    displayResult(b64result);
                                }
                            });
                            return;
                        }*/

                        console.warn("Transformer returned an invalid value" + (values.length > 1? " at line " + (index + 1): ""));
                        return value;
                    }

                    //addToHistory();

                    //displayResult(result);

                    return result;
                } catch(e) {
                    error("An error occured: " + e, 4000);
                    throw e;
                }
            }));
            
            addToHistory();

            displayResult(finalResult.join("\n"));
            
        }

        function generate(generator, params) {
            if (typeof generator != "function") {
                console.warn("generator is not a function.");
                return;
            }

            try {
                const result = generator(params);

                if (typeof result != "string") {
                    console.warn("Transformer returned an invalid value.");
                    return;
                }

                addToHistory();

                displayResult(result);
            } catch(e) {
                error("An error occured: " + e, 4000);
                throw e;
            }
        }

        function getValueElement() {
            return document.getElementById("value");
        }

        function addToHistory() {
            let value = getValueElement().value;
            
            if(value.length == 0) {
                return;
            }
            
            let history = JSON.parse(sessionStorage.getItem("history")) || [];

            //prevent history filling when changing random size
            if(history.length > 0 && history[history.length-1].t > new Date().valueOf() - 300) {
                return;
            }

            if(history.length > 32) {
                history = history.sort((a, b) => a.t - b.t).splice(1);
            }

            history.push(
                {
                    "v": value,
                    "t": new Date().valueOf()
                });

            refreshHistoryItems(history);
            sessionStorage.setItem("history", JSON.stringify(history));
        }

        function refreshHistoryItems(history) {
            historyItems = document.getElementById("historyItems");
            historyItems.innerHTML = "";
            for(let i = history.length - 1; i >= 0; i--) {
                let historyItem = document.createElement("div");
                historyItem.setAttribute("class", "historyItem");
                historyItem.setAttribute("ondblclick", "setFromHistory(" + i + ");");
                //TODO add preview on mouse over
                //TODO add set button
                //TODO add insert button
                //TODO add remove button
                historyItem.innerText = history[i].v;
                historyItems.appendChild(historyItem);
            }
        }

        function setFromHistory(index) {
            let history = JSON.parse(sessionStorage.getItem("history"));
            getValueElement().value = history[index].v;
            flashValue();
        }

        function initHistory() {
            if(typeof(sessionStorage.getItem("history")) !== "string") {
                sessionStorage.setItem("history", JSON.stringify([]));
            } else {
                refreshHistoryItems(JSON.parse(sessionStorage.getItem("history")));
            }
        }

        function isSelectionMode() {
            return getSelectionMode() === "selection";
        }

        function isCopyMode() {
            return document.getElementById("cbCopy").checked;
        }

        function flashValue() {
            const valueTextArea = getValueElement();
            const color = valueTextArea.style.backgroundColor;
            valueTextArea.style.backgroundColor = "gray";
            setTimeout(() => { valueTextArea.style.backgroundColor = color; }, 150);
        }

        function displayResult(result) {
            const valueTextArea = getValueElement();
            if (isCopyMode()) {
                flashValue()

                copyToClipboard(result);
            } else {
                if (isSelectionMode()) {
                    const currentValue = valueTextArea.value;
                    let value = currentValue.substr(0, cursorPos.start) + result + currentValue.substr(cursorPos.end, currentValue.length - cursorPos.end);

                    valueTextArea.value = value;

                    valueTextArea.selectionStart = valueTextArea.selectionEnd = cursorPos.start

                    //preventing scroll to bottom on large texts
                    valueTextArea.blur();
                    valueTextArea.focus();
                    cursorPos.end = cursorPos.start + result.length;
                    
                    valueTextArea.setSelectionRange(cursorPos.start, cursorPos.end);

                    valueTextArea.focus();

                } else {
                    valueTextArea.value = result;
                }
            }
        }

        const auxiliary = {

            uuidv4: function () {
                try {
                    return crypto.randomUUID();
                } catch (e) {
                    //fallback in case of insecure context being used or unavailable
                    console.error(e);
                    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
                    );
                }
            },

            utf8ToBase64: function (str) {
                const encoder = new TextEncoder();
                const uint8Array = encoder.encode(str);
                return btoa(String.fromCharCode.apply(null, uint8Array));
            },

            base64ToUtf8: function (base64Str) {
                const binaryString = atob(base64Str);
                const uint8Array = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    uint8Array[i] = binaryString.charCodeAt(i);
                }
                const decoder = new TextDecoder();
                return decoder.decode(uint8Array);
            },

            // detects if a string is valid JSON, malformed JSON, or not JSON at all.
            // Returns:
            //   - true: if the string is valid JSON.
            //   - false: if the string is not trying to be JSON.
            //   - object: with error details if the string is a malformed JSON.
            isJson: function (str) {
                if (typeof str !== 'string') {
                    return false;
                }
                const trimmed = str.trim();
                if (trimmed === '') {
                    return false;
                }

                // If the string contains newlines, it must start with '{', '[', or '"' 
                // to be considered a potentially valid multi-line JSON document.
                // This rejects cases like "123\nhello" which some parsers accept.
                if (trimmed.includes('\n') || trimmed.includes('\r')) {
                    const firstChar = trimmed[0];
                    if (!['{', '[', '"'].includes(firstChar)) {
                        return false;
                    }
                }
                
                try {
                    JSON.parse(str);
                    return true;
                } catch (e) {
                    // Heuristic to determine if it's a malformed attempt vs. not JSON at all.
                    const firstChar = trimmed[0];
                    if (['{', '[', '"'].includes(firstChar) || /^(-|true|false|null)/i.test(trimmed) || (firstChar >= '0' && firstChar <= '9')) {
                        return { name: e.name, message: e.message, exception: e };
                    }
                    return false;
                }
            },

            // detects if a string is valid XML, malformed XML, or not XML at all.
            // Returns:
            //   - true: if the string is well-formed XML.
            //   - false: if the string is not trying to be XML.
            //   - object: with error details if the string is a malformed XML.
            isXml: function (str) {
                if (typeof str !== 'string') {
                    return false;
                }
                const trimmedStr = str.trim();
                if (trimmedStr === '') {
                    return false;
                }
                const xmlLikeRegex = /^\s*<(\?|!|(\w)|(\/))/;
                if (!xmlLikeRegex.test(trimmedStr)) {
                    return false;
                }
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(str, "application/xml");
                const parserError = xmlDoc.querySelector("parsererror");
                if (parserError) {
                    return {
                        name: "XMLParserError",
                        message: parserError.textContent || "Malformed XML",
                        details: parserError
                    };
                }
                return true;
            },

            // detects if a string is Base64 encoded, supporting multi-line input.
            isBase64: function(str) {
                if (typeof str !== 'string' || str.trim() === '') {
                    return false;
                }
                const cleanStr = str.replace(/\s/g, '');
                if (cleanStr.length % 4 !== 0) {
                    return false;
                }
                const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                return base64Regex.test(cleanStr);
            },

            // detects if a string is Hex encoded, supporting multi-line input.
            isHex: function(str) {
                if (typeof str !== 'string' || str.trim() === '') {
                    return false;
                }
                const cleanStr = str.replace(/\s/g, '');
                if (cleanStr.length === 0) {
                    return false;
                }
                if (cleanStr.length % 2 !== 0) {
                    return false;
                }
                const hexRegex = /^[0-9a-fA-F]+$/;
                return hexRegex.test(cleanStr);
            },
            
            isYaml: function (str) {
                if (typeof str !== 'string' || str.trim() === '') {
                    return false;
                }
                const yamlIndicators = [
                    /:\s*$/m,               // key:
                    /^\s*-\s+/m,            // - item
                    /^\s*\w+\s*:\s*.+$/m,   // key: value
                    /^\s*#/,                // comment
                    /^\s*---\s*$/m          // document start
                ];
                for (const regex of yamlIndicators) {
                    if (regex.test(str)) {
                        return true;
                    }
                }
                return false;
            },

            yamlToObject: function(str) {
                //TODO
            }
        };

        //Generators
        const gens = (() => {

            //private functions


            //public functions
            return {
                generateGuid: function () {
                    return auxiliary.uuidv4();
                },

                randomString: function (params) {
                    const rndStringParams = params.loadParams();
                    const length = rndStringParams.length;

                    let validTypes = [];

                    if (rndStringParams.lower === true) {
                        validTypes.push((r) => { return String.fromCharCode(r % 26 + 97); });
                    }

                    if (rndStringParams.upper === true) {
                        validTypes.push((r) => { return String.fromCharCode(r % 26 + 65); });
                    }

                    if (rndStringParams.digits === true) {
                        validTypes.push((r) => { return String.fromCharCode(r % 10 + 48); });
                    }

                    if (rndStringParams.special === true && rndStringParams.specialChars.length > 0) {
                        validTypes.push((r) => {
                            const chars = rndStringParams.specialChars;
                            return chars[r % chars.length];
                        });
                    }

                    //[\]^_!"#$%&'()*+,-./`:;<=>?{|}~
                    // escaped: "[\\]^_!\"#$%&\'()*+,-./`:;<=>?{|}~"
                    // pattern: [\[\\\]\^_!"#\$%&'\(\)\*\+,-\.\/`:;<=>\?\{\|\}~]+

                    let result = "";

                    if (validTypes.length > 0) {
                        const types = crypto.getRandomValues(new Uint8Array(length));
                        const chars = crypto.getRandomValues(new Uint8Array(length));

                        for (let i = 0; i < length; i++) {
                            const type = types[i] % validTypes.length;
                            result += validTypes[type](chars[i]);
                        }
                    }

                    return result;
                },


                isoDateTime: function() {
                    return new Date().toISOString();
                },

                epoch: function() {
                    return new Date().valueOf().toString();
                }
                
                //Add more generators here.

            }
        })();


        //Transformers
        const trs = (() => {

            //private functions
            function escapeHtmlChar(original, xmlSafe) {
                let found = true;

                let thechar = original.charCodeAt(0);

                switch (thechar) {
                    case 60: return "&lt;"; break; //<
                    case 62: return "&gt;"; break; //>
                    case 34: return "&quot;"; break; //"

                    case 38: return "&amp;"; break; //&
                    default: found = false; break;
                }

                if (!xmlSafe) {
                    switch (thechar) {
                        case 198: return "&AElig;"; break;
                        case 193: return "&Aacute;"; break;
                        case 194: return "&Acirc;"; break;
                        case 192: return "&Agrave;"; break;
                        case 197: return "&Aring;"; break;
                        case 195: return "&Atilde;"; break;
                        case 196: return "&Auml;"; break;
                        case 199: return "&Ccedil;"; break;
                        case 208: return "&ETH;"; break;
                        case 201: return "&Eacute;"; break;
                        case 202: return "&Ecirc;"; break;
                        case 200: return "&Egrave;"; break;
                        case 203: return "&Euml;"; break;
                        case 205: return "&Iacute;"; break;
                        case 206: return "&Icirc;"; break;
                        case 204: return "&Igrave;"; break;
                        case 207: return "&Iuml;"; break;
                        case 209: return "&Ntilde;"; break;
                        case 211: return "&Oacute;"; break;
                        case 212: return "&Ocirc;"; break;
                        case 210: return "&Ograve;"; break;
                        case 216: return "&Oslash;"; break;
                        case 213: return "&Otilde;"; break;
                        case 214: return "&Ouml;"; break;
                        case 222: return "&THORN;"; break;
                        case 218: return "&Uacute;"; break;
                        case 219: return "&Ucirc;"; break;
                        case 217: return "&Ugrave;"; break;
                        case 220: return "&Uuml;"; break;
                        case 221: return "&Yacute;"; break;
                        case 225: return "&aacute;"; break;
                        case 226: return "&acirc;"; break;
                        case 230: return "&aelig;"; break;
                        case 224: return "&agrave;"; break;
                        case 229: return "&aring;"; break;
                        case 227: return "&atilde;"; break;
                        case 228: return "&auml;"; break;
                        case 231: return "&ccedil;"; break;
                        case 233: return "&eacute;"; break;
                        case 234: return "&ecirc;"; break;
                        case 232: return "&egrave;"; break;
                        case 240: return "&eth;"; break;
                        case 235: return "&euml;"; break;
                        case 237: return "&iacute;"; break;
                        case 238: return "&icirc;"; break;
                        case 236: return "&igrave;"; break;
                        case 239: return "&iuml;"; break;
                        case 241: return "&ntilde;"; break;
                        case 243: return "&oacute;"; break;
                        case 244: return "&ocirc;"; break;
                        case 242: return "&ograve;"; break;
                        case 248: return "&oslash;"; break;
                        case 245: return "&otilde;"; break;
                        case 246: return "&ouml;"; break;
                        case 223: return "&szlig;"; break;
                        case 254: return "&thorn;"; break;
                        case 250: return "&uacute;"; break;
                        case 251: return "&ucirc;"; break;
                        case 249: return "&ugrave;"; break;
                        case 252: return "&uuml;"; break;
                        case 253: return "&yacute;"; break;
                        case 255: return "&yuml;"; break;
                        case 162: return "&cent;"; break;
                        default:
                            found = false;
                            break;
                    }
                }

                if (!found) {
                    const hex = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');
                    if (thechar > 127) {
                        const c = thechar;
                        const a4 = c % 16;
                        c = Math.floor(c / 16);
                        const a3 = c % 16;
                        c = Math.floor(c / 16);
                        const a2 = c % 16;
                        c = Math.floor(c / 16);
                        const a1 = c % 16;
                        return "&#x" + hex[a1] + hex[a2] + hex[a3] + hex[a4] + ";";
                    }
                    else {
                        return original;
                    }
                }
            }

            function encodeChar(original, skipNewLine) {
                if (skipNewLine && original == '\n') return;
                let found = true;
                const thecharchar = original.charAt(0);
                const thechar = original.charCodeAt(0);
                switch (thecharchar) {
                    case '\n': return "\\n"; break; //newline
                    case '\r': return "\\r"; break; //Carriage return
                    case '\'': return "\\'"; break;
                    case '"': return "\\\""; break;
                    case '\\': return "\\\\"; break;
                    case '\t': return "\\t"; break;
                    case '\b': return "\\b"; break;
                    case '\f': return "\\f"; break;

                    default:
                        found = false;
                        break;
                }
                if (!found) {
                    const hex = new Array('0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');

                    if (thechar > 127) {
                        let c = thechar;
                        const a4 = c % 16;
                        c = Math.floor(c / 16);
                        const a3 = c % 16;
                        c = Math.floor(c / 16);
                        const a2 = c % 16;
                        c = Math.floor(c / 16);
                        const a1 = c % 16;
                        return "\\u" + hex[a1] + hex[a2] + hex[a3] + hex[a4] + "";
                    }
                    else {
                        return original;
                    }
                }


            }

            function xslTransform(source, xslTransformer) {
                const xmlDoc = new DOMParser().parseFromString(source, 'application/xml');
                const xsltDoc = new DOMParser().parseFromString(xslTransformer, 'application/xml');
                const xsltProcessor = new XSLTProcessor();    
                xsltProcessor.importStylesheet(xsltDoc);
                let resultDoc = xsltProcessor.transformToDocument(xmlDoc);
                const result = new XMLSerializer().serializeToString(resultDoc);

                //check for errors
                const resultParser = new DOMParser();
                resultDoc = resultParser.parseFromString(result, "application/xml");

                const errorElem = xmlDoc.getElementsByTagName("parsererror");
                if(errorElem.length > 0) {
                    error("Error parsing value: " + errorElem[0].getElementsByTagName("div")[0].innerHTML, 5000);
                    return source;
                }
                return result;
            }

            const prettifyXml = function(sourceXml, pretty, paddingChars) {

                let resultXml = xslTransform(sourceXml, [
                    // describes how we want to modify the XML - indent everything
                    '<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">',
                    '  <xsl:strip-space elements="*"/>',
                    '  <xsl:template match="para[content-style][not(text())]">', // change to just text() to strip space in text nodes
                    '    <xsl:value-of select="normalize-space(.)"/>',
                    '  </xsl:template>',
                    '  <xsl:template match="node()|@*">',
                    '    <xsl:copy><xsl:apply-templates select="node()|@*"/></xsl:copy>',
                    '  </xsl:template>',
                    '  <xsl:output indent="' + (pretty? 'yes': 'no') + '"/>',
                    '</xsl:stylesheet>',
                ].join('\n'));

                if(pretty == true) {
                    // Replace indentation 2 spaces with padding chars

                    if(paddingChars !== "  ") {

                        function replacer(match, p1, offset, string) {
                            return match.replaceAll("  ", paddingChars);
                        }
                        resultXml = resultXml.replace(/>\n(\s\s)+</g, replacer);
                    }
                }

                return resultXml;
            };

            function formatXml(xml, pretty, paddingChars) {

                try {
                    return prettifyXml(xml, pretty, paddingChars)
                } catch (e) {
                    console.warn(e);
                    // use fallback code bellow in case of exception
                }

                let formatted = '';
                const reg = /(>)(<)(\/*)/g;
                const paddingStr = paddingChars;
                xml = xml.replace(reg, '$1\r\n$2$3');
                let pad = 0;
                const lines = xml.split('\r\n');
                for (var index = 0; index < lines.length; index++) {
                    const node = lines[index];
                    let indent = 0;
                    if (node.match(/.+<\/\w[^>]*>$/)) {
                        indent = 0;
                    } else if (node.match(/^<\/\w/)) {
                        if (pad != 0) {
                            pad -= 1;
                        }
                    } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
                        indent = 1;
                    } else {
                        indent = 0;
                    }

                    let padding = '';
                    for (let i = 0; i < pad; i++) {
                        padding += paddingStr;
                    }

                    formatted += padding + node + '\r\n';
                    pad += indent;
                }
                return formatted;
            }

            function encodeUrlToken(input) {
                const ret = input.replace(/\+/g, "-").replace(/\//g, "_");
                if (ret.length == 0)
                    return "";
                const noPadding = ret.replace(/=+$/, "");
                return noPadding + (ret.length - noPadding.length).toString();
            }

            function decodeUrlToken(input) {
                const ec = parseInt(input.substring(input.length - 1));
                let temp = input.replace(/\-/g, "+").replace(/\_/g, "/");
                temp = temp.substring(0, temp.length - 1);
                return temp + "===".substring(0, ec);
            }

            function indexes(value, toFind, startingAt, found) {
                if(typeof(found) == "undefined") { found = []; }
                if(typeof(startingAt) == "undefined") { startingAt = 0; }

                const idx = value.indexOf(toFind, startingAt);
                
                if(idx == -1) { return found; }

                found.push(idx);
                return indexes(value, toFind, idx + toFind.length, found);
            }

            function sortObject(unordered, sortArrays = false, reverse = false) {
                if (!unordered || typeof unordered !== 'object') {
                    return unordered;
                }

                if (Array.isArray(unordered)) {
                    const newArr = unordered.map((item) => sortObject(item, sortArrays, reverse));
                    if (sortArrays) {
                        newArr.sort();
                        if(reverse === true) {
                            newArr.reverse();
                        }
                    }
                    return newArr;
                }

                const ordered = {};
                const keys = Object.keys(unordered).sort();
                if(reverse === true) {
                    keys.reverse();
                }

                keys.forEach((key) => {
                    ordered[key] = sortObject(unordered[key], sortArrays, reverse);
                });
                return ordered;
            }


            async function collectStream(stream) {
                const reader = stream.getReader();
                let chunks = [];
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }
                    chunks.push(value);
                }
                return new Uint8Array(await new Blob(chunks).arrayBuffer());
            }

            // public functions
            return {
                urlencode: function (value) {
                    return encodeURIComponent(value);
                },

                urldecode: function (value) {
                    try {
                        return decodeURIComponent(value);
                    }
                    catch (e) {
                        console.error(e);
                        return -1;
                    }
                },

                htmlencode: function (value) {
                    return document.createElement('a').appendChild(
                        document.createTextNode(value)).parentNode.innerHTML;
                },

                htmlencode2: function (value, params) {
                    let result = "";
                    const xmlSafe = params.xmlSafe() == true;

                    for (let i = 0; i < value.length; i++) {
                        result += escapeHtmlChar(value[i], xmlSafe);
                    }

                    return result;
                },

                htmldecode: function (value) {
                    const a = document.createElement('a');
                    a.innerHTML = value;
                    return a.textContent;
                },

                base64encode: function (value) {
                    try {
                        return auxiliary.utf8ToBase64(value);
                    } catch(e) {
                        console.error(e);
                        console.error("Falling back to legacy btoa.");
                        return window.btoa(value);
                    }
                },

                base64decode: function (value) {
                    try {
                        return auxiliary.base64ToUtf8(value);
                    } catch(e) {
                        console.error(e);
                        console.error("Falling back to legacy atob.");
                        try {
                            return window.atob(value);
                        }
                        catch (e) {
                            console.error(e);
                            warn("Invalid base64 text");
                            return -1;
                        }
                    }
                    
                },

                hexencode: function (value) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += '' + value.charCodeAt(i).toString(16).padStart(2, "0");
                    }

                    return hex;
                },

                hexdecode: function (value) {
                    const hex = value;
                    let str = "";
                    for (let i = 0; i < hex.length; i += 2) {
                        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
                    }

                    return str;
                },

                CLikeLang_StringEscape: function (value) {
                    const preescape = "" + value;
                    let escaped = "";

                    for (let i = 0; i < preescape.length; i++) {
                        escaped = escaped + encodeChar(preescape.charAt(i), false);
                    }

                    return escaped;
                },

                CLikeLang_StringUnescape: function (value) {
                    try {
                        const replacement = `##TEMP##${auxiliary.uuidv4()}##`;
                        const temp = eval(`new String(\'${value.replaceAll("'", replacement)}\')`);
                        return temp.replaceAll(replacement, "'");
                    } catch (error) {
                        console.error(error);
                        warn("Could not unescape. Make sure you have no invalid characters like line breaks.", 5000);
                        return value;
                    }
                },

                prettyPrint: function(value, params) {
                    const padding = params.getPadding();
                    const lang = params.getFormatingLang();
                    switch (lang) {
                        case "JSON":
                            return JSON.stringify(JSON.parse(value), null, padding);
                        case "XML":
                            return formatXml(value, true, padding);
                        default:
                            console.error("Unsupported formatting lang");
                            return -1;
                    }
                },

                minify: function(value, params) {
                    const lang = params.getFormatingLang();
                    switch (lang) {
                        case "JSON":
                            return JSON.stringify(JSON.parse(value));
                        case "XML":
                            return formatXml(value, false);
                        default:
                            console.error("Unsupported formatting lang");
                            return -1;
                    }
                },

                toUpperCase: function (value) {
                    return value.toUpperCase();
                },

                toLowerCase: function (value) {
                    return value.toLowerCase();
                },

                replicate: function (value) {
                    return value + value;
                },

                replicate: function (value, params) {

                    const mode = params.getReplicateMode()

                    if(mode === "simple") {
                        return value + value;
                    }
                    
                    const template = value;
                    
                    const placeholder = params.getReplicatePlaceholder();

                    let result = "";
                    if (mode === "range") {
                        let start = params.getReplicateRangeStart();
                        let end = params.getReplicateRangeEnd();
                        
                        if(start > end) {
                            for(let i = start; i >= end; i--) {
                                result += template.replaceAll(placeholder, i);
                            }
                        } else {
                            for(let i = start; i <= end; i++) {
                                result += template.replaceAll(placeholder, i);
                            }
                        }
                        
                    } else {
                        const items = params.getReplicateTemplateItems();
                        for(let i = 0; i < items.length; i++) {
                            result += template.replaceAll(placeholder, items[i]);
                        }
                    }
                    
                    return result;
                },

                sort: function(value, params) {
                    return params.isAscending()?
                        value.split("\n").sort().join("\n") :
                        value.split("\n").sort().reverse().join("\n");
                },

                sortObject: function (value, params) {
                    let unsortedObject = JSON.parse(value);
                    return JSON.stringify(sortObject(unsortedObject, false, !params.isAscending()), null, params.getPadding());
                },

                CTypeLang_Stringify: function(value) {
                    const lines = value.split("\n");
                    let result = "";
                    for(let i = 0; i < lines.length; i++) {
                        result += (i == 0? "": "+ ")
                        + "\"" + trs.CLikeLang_StringEscape(lines[i])
                        + (i == lines.length - 1? "\"": "\\n\"" + "\n");
                    }
                    return result;
                },

                CTypeLang_Unstringify: function(value) {
                    const lines = value.split(/\s*\n\s*\+\s*/);
                    let result = "";
                    for(let i = 0; i < lines.length; i++) {
                        if(lines[i].match(/^".*"$/) == null) {
                            warn("Could not unstringify. Make sure you have valid C language type strings.", 5000);
                            return value;
                        }
                        result += trs.CLikeLang_StringUnescape(lines[i].substr(1, lines[i].length - 2));
                    }
                    return result;
                },

                xmlToJson: function(value) {
                    return xmlToJsonAux(value);
                },

                replace: function(value, params) {
                    const replaceValue = params.replaceValue();
                    const replaceWith = params.replaceWith();
                    const replaceAll = params.all();
                    const caseSensitive = params.caseSensitive();

                    if(replaceValue == "") {
                        warn("Nothing to replace");
                        return -1;
                    }

                    let result = value;

                    if(params.isRegex()) {
                        let regex = null;
                        try {
                            regex = new RegExp(replaceValue, "m" + (caseSensitive == true? "": "i") + (replaceAll == true? "g": ""));
                        } catch(e) {
                            console.error(e);
                            error(e.message);
                            return -1;
                        }

                        result = value.replace(regex, replaceWith);

                        return result;
                        
                    } else {
                        if(caseSensitive == true) {
                            if(replaceAll == true) {
                                result = value.replaceAll(replaceValue, replaceWith);
                            } else {
                                result = value.replace(replaceValue, replaceWith);
                            }
                            if(result == value) {
                                info("'"+ replaceValue + "'" + " was not found.")
                                return -1;
                            }
                            return result;
                        } else {
                            if(replaceAll == true) {
                                let found = indexes(value.toLowerCase(), replaceValue.toLowerCase());
                                if(found.length == 0) {
                                    info("'"+ replaceValue + "'" + " was not found.")
                                    return -1;
                                }
                                let result = value;
                                found.reverse().forEach(foundIndex => result = result.substr(0, foundIndex) + replaceWith + result.substr(foundIndex + replaceValue.length));
                                return result;
                            } else {
                                let foundIndex = value.toLowerCase().indexOf(replaceValue.toLowerCase());
                                if(foundIndex == -1) {
                                    info("'"+ replaceValue + "'" + " was not found.")
                                    return -1;
                                }
                                
                                return value.substr(0, foundIndex) + replaceWith + value.substr(foundIndex + replaceValue.length);
                            }
                        }
                    }
                },

                compress: async function (text, params) {
                    const algorithm = params.compressAlgorithm();
                    const encoder = new TextEncoder();
                    const utf8Bytes = encoder.encode(text);
                    const compressedStream = new CompressionStream(algorithm);
                    const writer = compressedStream.writable.getWriter();
                    writer.write(utf8Bytes);
                    writer.close();
                    const compressedBytes = await collectStream(compressedStream.readable);
                    const base64String = btoa(String.fromCharCode(...new Uint8Array(compressedBytes)));
                    return base64String;
                },

                decompress: async function (base64String, params) {
                    const algorithm = params.compressAlgorithm();
                    const compressedBytes = Uint8Array.from(atob(base64String), c => c.charCodeAt(0));
                    const decompressedStream = new DecompressionStream(algorithm);
                    const writer = decompressedStream.writable.getWriter();
                    writer.write(compressedBytes);
                    writer.close();
                    const decompressedBytes = await collectStream(decompressedStream.readable);
                    const decoder = new TextDecoder();
                    const decompressedText = decoder.decode(decompressedBytes);
                    return decompressedText;
                },

                digest: async function (text, params) {
                    const algorithm = params.digestAlgorithm();
                    const outputFormat = params.digestOutputFormat();
                    
                    const msgUint8 = new TextEncoder().encode(text); // encode as (utf-8) Uint8Array
                    const hashBuffer = await window.crypto.subtle.digest(algorithm, msgUint8); // hash the message
                    const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array

                    if(outputFormat === "hex") {
                        return hashArray
                        .map((b) => b.toString(16).padStart(2, "0"))
                        .join(""); // convert bytes to hex string
                    } else if (outputFormat === "base64") {
                        return btoa(String.fromCharCode(...hashArray));
                    }
                }
                
 
                // TODO: add more transformers here

            };
        })();


        function copyToClipboard(value) {
            const toCopy = document.createElement("textarea");
            toCopy.style.width = 0;
            toCopy.style.height = 0;
            toCopy.value = value;
            document.body.appendChild(toCopy);

            /* Select the text field */
            toCopy.select();
            toCopy.setSelectionRange(0, value.length + 1); /*For mobile devices*/

            /* Copy the text inside the text field */
            document.execCommand("copy");

            document.body.removeChild(toCopy);

            info("Value " + (value.length < 100 ? value : "") + " copied to clipboard!");
        }

        function clearValue() {
            const valueTextArea = getValueElement();
            valueTextArea.value = "";
            valueTextArea.focus();
        }

        function copyValue() {
            const valueTextArea = getValueElement();
            copyToClipboard(valueTextArea.value);
            info("Value copied to clipboard!");
        }

        function cropToSelection() {
            const valueTextArea = getValueElement();
            valueTextArea.value = valueTextArea.value.substr(cursorPos.start, cursorPos.end - cursorPos.start);
            valueTextArea.focus();
        }

        function saveToFile() {
            const valueTextArea = getValueElement();
            const value = isSelectionMode()? valueTextArea.value.substr(cursorPos.start, cursorPos.end - cursorPos.start): valueTextArea.value;
            if(value.length == 0) {
                info("Nothing to save.");
                return;
            }
            const a = document.createElement("a");
            a.href = window.URL.createObjectURL(new Blob([value], {type: "text/plain"}));
            a.download = "file.txt";
            a.click();
        }

        let cursorPos = {
            start: -1,
            end: -1,
            line: -1,
            column: -1
        };
        
        function getCursorPos(input) {
            if ("selectionStart" in input && document.activeElement == input) {
                cursorPos.start = input.selectionStart;
                cursorPos.end = input.selectionEnd;
                cursorPos.line = input.value.substr(0, input.selectionStart).split(/\r?\n|\r/).length;
                cursorPos.column = getCol(input, input.selectionStart);
                return cursorPos;
            }
            else if (input.createTextRange) {
                const sel = document.selection.createRange();
                if (sel.parentElement() === input) {
                    var rng = input.createTextRange();
                    rng.moveToBookmark(sel.getBookmark());
                    for (var len = 0;
                        rng.compareEndPoints("EndToStart", rng) > 0;
                        rng.moveEnd("character", -1)) {
                        len++;
                    }
                    rng.setEndPoint("StartToStart", input.createTextRange());
                    for (var pos = { start: 0, end: len };
                        rng.compareEndPoints("EndToStart", rng) > 0;
                        rng.moveEnd("character", -1)) {
                        pos.start++;
                        pos.end++;
                    }

                    pos.line = input.value.substr(0, input.selectionStart).split(/\r?\n|\r/).length;
                    pos.column = getCol(input, input.selectionStart);
                    cursorPos = pos;
                    return cursorPos;
                }
            }
            cursorPos = {
                start: -1,
                end: -1,
                line: -1,
                column: -1
            };
            return cursorPos;
        }

        function formatWhitepacePadding() {
            return (document.getElementById("useTabs").checked == true) ? '\t' : '  ';
        }

        function getFormattingLang() {
            return document.getElementById("formattingLang").value;
        }

        function xmlSafe() {
            return document.getElementById("xmlSafe").checked;
        }

        function sortIsAscending() {
            return !document.getElementById("sortDescending").checked;
        }

        function isReplaceRegex() {
            return document.getElementById("replaceRegex").checked;
        }

        function getReplaceValue() {
            return document.getElementById("replaceValue").value;
        }

        function getReplaceWith() {
            let replaceWith = document.getElementById("replaceWith").value;
            return getReplaceEscaped()? trs.CLikeLang_StringUnescape(replaceWith) : replaceWith;
        }

        function getCompressAlgorithm() {
            return document.getElementById("compressAlgorithm").value;
        }

        function getDigestAlgorithm() {
            return document.getElementById("digestAlgorithm").value;
        }
        
        function getDigestOutputFormat() {
            return document.getElementById("digestOutputFormat").value;
        }

        function getReplaceAll() {
            return document.getElementById("replaceAll").checked;
        }

        function getReplaceCaseSensitive() {
            return document.getElementById("replaceCaseSensitive").checked;
        }
        
        function getReplaceEscaped() {
            return document.getElementById("replaceEscaped").checked;
        }

        function getCol(value, start) {
            let index = start;
            let char = '\n';
            do {
                char = value.value[-1 + index--];
            } while (char != '\n' && char != '\r' && index >= 0);
            return start - index - 1;
        }

        window.valueTouched = new Date();
        function fetchData() {
            if(document.activeElement == getValueElement()) {
                const valueTextArea = getValueElement();
                const pos = getCursorPos(valueTextArea);

                document.getElementById("start").innerHTML = pos.start;
                document.getElementById("end").innerHTML = pos.end;
                document.getElementById("selection").innerHTML = pos.end - pos.start;
                document.getElementById("length").innerHTML = valueTextArea.value.length;

                document.getElementById("line").innerHTML = pos.line;
                document.getElementById("col").innerHTML = pos.column;

                window.valueTouched = new Date();
            }
        }

        function detectFormatOrLanguage() {
            const valueTextArea = getValueElement();
            const value = valueTextArea.value;

            // Check for JSON (three-state return)
            const jsonCheckResult = auxiliary.isJson(value);
            if (jsonCheckResult === true) {
                return { type: "JSON", valid: true };
            } else if (typeof jsonCheckResult === 'object') {
                console.error("Malformed JSON detected: " + jsonCheckResult.message);
                return { type: "JSON", valid: false, error: jsonCheckResult };
            }

            // Check for XML (three-state return)
            const xmlCheckResult = auxiliary.isXml(value);
            if (xmlCheckResult === true) {
                return { type: "XML", valid: true };
            } else if (typeof xmlCheckResult === 'object') {
                console.error("Malformed XML detected: " + xmlCheckResult.message);
                return { type: "XML", valid: false, error: xmlCheckResult };
            }

            // Check for YAML (boolean return)
            if (auxiliary.isYaml(value) === true) {
                return { type: "YAML", valid: true };
            }
            
            // Check for Base64 (boolean return)
            if (auxiliary.isBase64(value) === true) {
                return { type: "Base64", valid: true };
            }
            
            // Check for Hex (boolean return)
            if (auxiliary.isHex(value) === true) {
                return { type: "Hex", valid: true };
            }

            // Format not detected
            return null;
        }

        function rndSpecialChanged(event) {
            if (event.target.checked == false) {
                document.getElementById('rndSpecialChars').setAttribute("disabled", "");
            } else {
                document.getElementById('rndSpecialChars').removeAttribute("disabled");
            }
        }

        let stopRndChangeEvent = false;

        function preventInvalidSpecialChars(event) {
            if (event.keyCode < 32) {
                return true;
            }
            const pattern = new RegExp(event.target.pattern);

            return pattern.test(event.key);
        }

        function preventInvalidRndLength(event) {
            if(parseInt(this.value) > parseInt(this.max) || parseInt(this.value) < parseInt(this.min)) {
                this.value = this.max;
            }
        }

        function adjustRndStringSlider(slider) {
            slider.style.backgroundSize = (slider.value - slider.min) * 100 / (slider.max - slider.min) + '% 100%';
        }

        function getRandomStringParams() {
            return {
                length: document.getElementById("rndStringLength").value,
                lower: document.getElementById("rndLower").checked,
                upper: document.getElementById("rndUpper").checked,
                digits: document.getElementById("rndDigits").checked,
                special: document.getElementById("rndSpecial").checked,
                specialChars: document.getElementById("rndSpecial").checked == true ? document.getElementById("rndSpecialChars").value : ""
            };
        }

        let messageId = null;
        function info(text, delay) {
            document.getElementById("messageType").innerHTML = "&#8505;&nbsp;Info";
            document.getElementById("messageText").innerText = text;

            document.getElementById("message").style.background = "aliceblue";
            document.getElementById("message").style.color = "#7070A0";

            document.getElementById("message").style.display = "flex";

            const id = auxiliary.uuidv4();
            messageId = id;
            window.setTimeout(function () { if (id != messageId) { return; } document.getElementById("message").style.display = "none"; }, typeof delay == "number" ? delay : 2000);
        }

        function warn(text, delay) {
            document.getElementById("messageType").innerHTML = "&#9888;&nbsp;Warning";
            document.getElementById("messageText").innerText = text;

            document.getElementById("message").style.background = "blanchedalmond";
            document.getElementById("message").style.color = "#806640";

            document.getElementById("message").style.display = "flex";

            const id = auxiliary.uuidv4();
            messageId = id;
            window.setTimeout(function () { if (id != messageId) { return; } document.getElementById("message").style.display = "none"; }, typeof delay == "number" ? delay : 2000);
        }

        function error(text, delay) {
            document.getElementById("messageType").innerHTML = "&#9888;&nbsp;Error";
            document.getElementById("messageText").innerText = text;

            document.getElementById("message").style.background = "coral";
            document.getElementById("message").style.color = "#905050";

            document.getElementById("message").style.display = "flex";

            const id = auxiliary.uuidv4();
            messageId = id;
            window.setTimeout(function () { if (id != messageId) { return; } document.getElementById("message").style.display = "none"; }, typeof delay == "number" ? delay : 2000);
        }

        function setWrap() {
            const valueElement = getValueElement();
            const wrap = !document.getElementById("cbWrap").checked;
            
            if (wrap) {
                valueElement.classList.remove("nowrap");
            } else {
                valueElement.classList.add("nowrap");
            }
        }

        function dropHandler(ev) {
            return;
            // TODO resume implementation
            console.log("File(s) dropped");

            // Prevent default behavior (Prevent file from being opened)
            ev.preventDefault();

            if (ev.dataTransfer.items) {
                // Use DataTransferItemList interface to access the file(s)
                [...ev.dataTransfer.items].forEach((item, i) => {
                // If dropped items aren't files, reject them
                if (item.kind === "file") {
                    const file = item.getAsFile();
                    console.log(`1 file[${i}].name = ${file.name}`);
                    debugger;


                    //reader = new FileReader();

                    //reader.readAsDataURL(file);
                }
                });
            } else {
                // Use DataTransfer interface to access the file(s)
                [...ev.dataTransfer.files].forEach((file, i) => {
                console.log(`2 file[${i}].name = ${file.name}`);
                debugger;
                });
            }
        }

        function selectReplicateTemplateItems() {
            const rawItems = document.getElementById("replicateTemplateItemsBuilder").value;

            let result = [];
            rawItems.split("\n").forEach(item => {
                if(item.trim().length > 0) {
                    result.push(item.trim());
                }
            });

            document.getElementById("replicateTemplateItems").value = result.join(",");
        }

        function fillReplicateTemplateItemsBuilder() {
            document.getElementById("replicateTemplateItemsBuilder").value =
                getReplicateTemplateItems().join("\n");
            
            document.querySelector(".overlay").style.display = "flex";
        }

        function getReplicateMode() {
            return document.getElementById("replicateMode").value;
        }

        function getReplicateRangeStart() {
            return parseInt(document.getElementById("replicateRangeStart").value);
        }
        function getReplicateRangeEnd() {
            return parseInt(document.getElementById("replicateRangeEnd").value);
        }
        
        function getReplicateTemplateItems() {
            return document.getElementById("replicateTemplateItems").value.split(",");
        }
        
        function getReplicatePlaceholder() {
            return document.getElementById("replicatePlaceholder").value.trim();
        }

        function selectReplicateMode() {
            const mode = getReplicateMode();

            if(mode === "simple") {
                document.getElementById("replicateParams").style.display = "none";
            } else {
                document.getElementById("replicateParams").style.display = "inherit";

                if(mode === "template") {
                    document.getElementById("replicateRange").style.display = "none";
                    document.getElementById("replicateTemplateItems").style.display = "inherit";
                    replicateTemplateItems
                } else {
                    document.getElementById("replicateRange").style.display = "inherit";
                    document.getElementById("replicateTemplateItems").style.display = "none";
                }
            }
        }

        function updateDetectedFormatDisplay(detected) {
            const detectedFormatDiv = document.getElementById("detectedFormatDiv");
            const formatIdentifier = document.getElementById("formatIdentifier");
            const formatValidity = document.getElementById("formatValidity");

            if(detected == null) {
                detectedFormatDiv.style.display = "none";
                formatIdentifier.innerText = "";
                formatValidity.innerText = "";
                return;
            }

            detectedFormatDiv.style.display = "block";
            formatIdentifier.innerText = detected.type;

            if(detected.valid === false) {
                formatIdentifier.classList.add("error-tag");
                formatIdentifier.classList.remove("success-tag");
                formatValidity.innerText = detected.error.message;
            } else {
                formatIdentifier.classList.remove("error-tag");
                formatIdentifier.classList.add("success-tag");
                formatValidity.innerText = "";
            }
        }

        /**
             * Renders a JavaScript object into a collapsible and expandable tree view.
             * @param {object} data The JavaScript object to render.
             * @param {string} containerElementId The ID of the container element to render the tree into.
             */
            function createObjectTreeView(data, containerElementId) {
                const container = document.getElementById(containerElementId);
                if (!container) {
                    console.error(`Container element with ID "${containerElementId}" not found.`);
                    return;
                }
                container.innerHTML = '';
                container.classList.add('object-tree-container');

                // --- 1. Inject CSS Styles ---
                const styleId = 'object-tree-styles';
                if (!document.getElementById(styleId)) {
                    const style = document.createElement('style');
                    style.id = styleId;
                    style.innerHTML = `
                        .object-tree-container {
                            font-family: Menlo, Monaco, 'Courier New', monospace;
                            font-size: 14px;
                            line-height: 1.5;
                        }
                        .node {
                            margin-left: 2em;
                            padding-left: 5px;
                            border-left: 1px dotted #ccc;
                        }
                        .header, .primitive-node {
                            display: flex;
                            align-items: center;
                        }
                        .header {
                            cursor: pointer;
                        }
                        .toggle {
                            width: 1.5em;
                            font-size: 0.8em;
                            color: #666;
                            transition: transform 0.1s ease;
                        }
                        .toggle.expanded {
                            transform: rotate(90deg);
                        }
                        .key {
                            font-weight: bold;
                            color: #663399; /* rebeccapurple */
                        }
                        .value {
                            margin-left: 0.5em;
                        }
                        .value.string { color: #d14; }
                        .value.number { color: #099; }
                        .value.boolean { color: #0000ff; }
                        .value.null { color: #888; }
                        .preview {
                            margin-left: 0.5em;
                            color: #888;
                            font-style: italic;
                        }
                        .children {
                            display: block;
                        }
                        .copy-btn {
                            margin-left: auto;
                            padding: 2px 8px;
                            font-size: 12px;
                            border: 1px solid #ccc;
                            border-radius: 4px;
                            background-color: #f0f0f0;
                            cursor: pointer;
                            visibility: hidden; /* Initially hidden */
                        }
                        .header:hover .copy-btn, .primitive-node:hover .copy-btn {
                            visibility: visible; /* Show on hover */
                        }
                        .copy-btn:hover { background-color: #e0e0e0; }
                        .copy-btn:active { background-color: #d0d0d0; }
                    `;
                    document.head.appendChild(style);
                }

            // --- 2. Helper to copy text and provide feedback ---
            function copyToClipboard(text, button) {
                navigator.clipboard.writeText(text).then(() => {
                    const originalText = button.textContent;
                    button.textContent = 'Copied!';
                    setTimeout(() => {
                        button.textContent = originalText;
                    }, 1500);
                }).catch(err => {
                    console.error('Failed to copy: ', err);
                    alert('Failed to copy text.');
                });
            }

            // --- 3. Recursive function to build the tree nodes ---
            function buildNode(key, value) {
                const node = document.createElement('div');
                node.className = 'node';
                const type = value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value;

                if (type === 'object' || type === 'array') {
                    // --- Complex Node (Object or Array) ---
                    const header = document.createElement('div');
                    header.className = 'header';

                    const toggle = document.createElement('span');
                    toggle.className = 'toggle expanded';
                    toggle.textContent = ''; // Right-pointing triangle

                    const keySpan = document.createElement('span');
                    keySpan.className = 'key';
                    keySpan.textContent = `${key}: `;

                    const preview = document.createElement('span');
                    preview.className = 'preview';
                    preview.textContent = type === 'array' ? `Array(${value.length})` : `Object`;

                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'copy-btn';
                    copyBtn.textContent = 'Copy JSON';
                    copyBtn.onclick = (e) => {
                        e.stopPropagation();
                        // For other formats, you could have a switch here
                        // or pass the format as an argument.
                        copyToClipboard(JSON.stringify(value, null, 2), copyBtn);
                    };

                    header.appendChild(toggle);
                    header.appendChild(keySpan);
                    header.appendChild(preview);
                    header.appendChild(copyBtn);
                    node.appendChild(header);

                    const childrenContainer = document.createElement('div');
                    childrenContainer.className = 'children';

                    const entries = type === 'array' ? value.entries() : Object.entries(value);
                    for (const [childKey, childValue] of entries) {
                        childrenContainer.appendChild(buildNode(childKey, childValue));
                    }
                    node.appendChild(childrenContainer);

                    // Toggle Logic
                    const toggleNode = () => {
                        const isExpanded = toggle.classList.toggle('expanded');
                        childrenContainer.style.display = isExpanded ? 'block' : 'none';
                    };
                    header.onclick = toggleNode;

                    // Start collapsed
                    toggleNode();

                } else {
                    // --- Primitive Node ---
                    node.classList.add('primitive-node');

                    const keySpan = document.createElement('span');
                    keySpan.className = 'key';
                    keySpan.textContent = `${key}: `;

                    const valueSpan = document.createElement('span');
                    valueSpan.className = `value ${type}`;
                    // Use JSON.stringify to correctly represent strings (with quotes) vs other primitives
                    valueSpan.textContent = JSON.stringify(value);

                    const copyBtn = document.createElement('button');
                    copyBtn.className = 'copy-btn';
                    copyBtn.textContent = 'Copy Value';
                    copyBtn.onclick = (e) => {
                        e.stopPropagation();
                        copyToClipboard(JSON.stringify(value), copyBtn);
                    };

                    node.appendChild(keySpan);
                    node.appendChild(valueSpan);
                    node.appendChild(copyBtn);
                }

                return node;
            }

            // --- 4. Build and append the root node ---
            const rootNode = buildNode('root', data);
            container.appendChild(rootNode);
        }

        // --- Example Usage ---
        const sampleObject = {
            id: "001",
            type: "donut",
            name: "Cake",
            ppu: 0.55,
            isPublished: true,
            author: null,
            batters: {
                batter: [
                    { id: "1001", type: "Regular" },
                    { id: "1002", type: "Chocolate" },
                    { id: "1003", type: "Blueberry" },
                    { id: "1004", type: "Devil's Food" }
                ]
            },
            topping: [
                { id: "5001", type: "None" },
                { id: "5002", type: "Glazed" },
                { id: "5005", type: "Sugar" },
                { id: "5007", type: "Powdered Sugar" },
                { id: "5006", type: "Chocolate with Sprinkles" },
                { id: "5003", type: "Chocolate" },
                { id: "5004", type: "Maple" }
            ]
        };

        // Render the object in the 'object-container' div when the page loads.
        //window.onload = () => {
        //    createObjectTreeView(sampleObject, 'object-container');
        //};

    </script>
</head>

<body>
    <textarea id="value" value="" placeholder="Text goes here..." autofocus ondrop="dropHandler(event);" spellcheck="false"></textarea>
    <div style="float: right;position: relative;font-size: small; margin-top: 0.2rem">
        Line: <span id="line"></span>
        <span style="margin-left: 10px;">Column: </span><span id="col"></span>
    </div>
    <div style="float: right;clear: right;position: relative;font-size: small;">
        Start: <span id="start"></span>
        <span style="margin-left: 10px;">End: </span><span id="end"></span>
        <span style="margin-left: 10px;">Selection: </span><span id="selection"></span>
        <span style="margin-left: 10px;">Length:</span><span id="length"></span>
    </div>
    <div style="float: right; clear: right; position: relative; font-size: small; padding-top: 0.3rem; text-align: end; display: none" id="detectedFormatDiv">
        <span id="formatIdentifier" class="error-tag" style="display: block; float: right;"></span>
        <span id="formatValidity" style="color: orange; padding-top: 0.2rem; display: block; clear: right; max-width: 25rem;"></span>
    </div>
    <div>
        <!--TODO review/improve url and html encoders-->
        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="URL Encode"
                onclick="transform(trs.urlencode);" /><br />
            <input type="button" class="button button-xsmall" value="URL Decode" onclick="transform(trs.urldecode);" />
            <hr/>
            <input type="button" class="button button-xsmall" value="HTML Encode"
                onclick="transform(trs.htmlencode2, {'xmlSafe': xmlSafe});" />
            <br />
            <label class="off-on">
                <input id="xmlSafe" type="checkbox" checked />
                <span class="off-on-slider round"></span>
            </label><label for="xmlSafe">XML safe?</label>
            <br />
            <input type="button" class="button button-xsmall" value="HTML Decode"
                onclick="transform(trs.htmldecode);" />
        </div>

        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="Base64 Encode"
                onclick="transform(trs.base64encode);" /><br />
            <input type="button" class="button button-xsmall" value="Base64 Decode"
                onclick="transform(trs.base64decode);" />
            <hr/>
            <input type="button" class="button button-xsmall" value="HEX Encode"
                onclick="transform(trs.hexencode);" /><br />
            <input type="button" class="button button-xsmall" value="HEX Decode"
                onclick="transform(trs.hexdecode);" />
        </div>

        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="String Escape"
                onclick="transform(trs.CLikeLang_StringEscape);" /><br />
            <input type="button" class="button button-xsmall" value="String Unescape"
                onclick="transform(trs.CLikeLang_StringUnescape);" />
            <hr/>
            <input type="button" class="button button-xsmall" value="Stringify"
                onclick="transform(trs.CTypeLang_Stringify);" /><br />
            <input type="button" class="button button-xsmall" value="Unstringify"
                onclick="transform(trs.CTypeLang_Unstringify);" />
        </div>

        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="Pretty Print"
                onclick="transform(trs.prettyPrint, { 'getPadding': formatWhitepacePadding, 'getFormatingLang': getFormattingLang });"><br />
            <input type="button" class="button button-xsmall" value="Minify"
                onclick="transform(trs.minify, { 'getFormatingLang': getFormattingLang });"><br/>
                <hr/>
            <select id="formattingLang" class="button button-xsmall" style="text-align: left;">
                <option selected value="JSON">
                    JSON
                </option>
                <option value="XML">
                    XML
                </option>
                <option value="YAML" disabled>
                    YAML
                </option>
            </select><br/>
            <label class="switch">
                <input type="checkbox" id="useTabs">
                <span class="slider round slider-padding"></span>
            </label>
        </div>
        
        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="Digest"
                onclick="transform(trs.digest, {'digestAlgorithm': getDigestAlgorithm, 'digestOutputFormat': getDigestOutputFormat });" /><br />
           
            <hr/>
            <select id="digestAlgorithm" class="button button-xsmall" style="text-align: left;">
                <option selected value="SHA-256">SHA-256</option>
                <option value="SHA-1">SHA-1</option>
                <option value="SHA-384">SHA-384</option>
                <option value="SHA-512">SHA-512</option>
            </select>
            <br/>
            <select id="digestOutputFormat" class="button button-xsmall" style="text-align: left;">
                <option selected value="hex">To HEX</option>
                <option value="base64">To Base64</option>
            </select>
        </div>

        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="Compress"
                onclick="transform(trs.compress, {'compressAlgorithm': getCompressAlgorithm });" /><br />
            <input type="button" class="button button-xsmall" value="Decompress"
                onclick="transform(trs.decompress, {'compressAlgorithm': getCompressAlgorithm });" />
            <hr/>
            <select id="compressAlgorithm" class="button button-xsmall" style="text-align: left;">
                <option selected value="deflate">
                    Deflate
                </option>
                <option value="deflate-raw">
                    Deflate Raw
                </option>
                <option value="gzip">
                    GZip
                </option>
            </select>
        </div>

        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="To UPPERCASE"
                onclick="transform(trs.toUpperCase);" /><br />
            <input type="button" class="button button-xsmall" value="To lowercase"
                onclick="transform(trs.toLowerCase);" />
            <!--TODO: to consider: camelCase, kebab-case, snake_case-->
        </div>

        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="Replicate"
                onclick="transform(trs.replicate, {'getReplicateMode': getReplicateMode, 'getReplicatePlaceholder': getReplicatePlaceholder, 'getReplicateRangeStart': getReplicateRangeStart, 'getReplicateRangeEnd': getReplicateRangeEnd, 'getReplicateTemplateItems': getReplicateTemplateItems});" /><br/>

            <select id="replicateMode" class="button button-xsmall"
                style="text-align: left;" onchange="selectReplicateMode()">
                <option value="simple">Simple</option>
                <option value="template">Template</option>
                <option value="range">Ranged</option>
            </select><br/>

            <div id="replicateParams" style="display: none;">
                <div id="replicateRange">
                    <input id="replicateRangeStart" type="number" value="1" min="0" />
                    <input id="replicateRangeEnd" type="number" value="10" min="0" style="margin-left: 58px" />
                </div>
                
                <input onfocus="fillReplicateTemplateItemsBuilder()" id="replicateTemplateItems" type="text" placeholder="Items" readonly />
                
                <br/>
                <br/>

                <small>Placeholder</small> <input id="replicatePlaceholder" type="text" value="##" style="width:88px" />
                <div class="overlay" style="position: fixed; top:0; bottom: 0; left: 0; right: 0; width: 100%; height: 100%; background-color: #000000bd; z-index: 1001; display: none;">
                    <div style="position: relative; width: 500px; height: 700px; background-color: #909090; margin: auto;">

                        <textarea id="replicateTemplateItemsBuilder" placeholder="items: one per line" style="height: 600px;" spellcheck="false"></textarea>
                
                        <div style="margin: auto;align-items: center;display: flex;height: 100px;width: fit-content;">
                            <button class="button button-xsmall" onclick="this.closest('.overlay').style.display='none'">Close</button>&nbsp;
                            <button class="button button-xsmall" onclick="this.closest('.overlay').style.display='none'; selectReplicateTemplateItems()">OK</button>
                        </div>
                        
                    </div>
                </div>
            </div>

            
        </div>
        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="Sort lines"
                onclick="transform(trs.sort, {'isAscending': sortIsAscending });" /><br />
            <input type="button" class="button button-xsmall" value="Sort JSON"
                onclick="transform(trs.sortObject, {'isAscending': sortIsAscending, 'getPadding': formatWhitepacePadding });" />
            <br/>
            <label class="switch">
                <input type="checkbox" id="sortDescending">
                <span class="slider round slider-sort"></span>
            </label>
        </div>
    </div>
    <hr />
    <div>
        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="Copy"
                onclick="copyValue();" title="Copy all text" /><br/>
            <input type="button" class="button button-xsmall" value="Clear"
                onclick="clearValue();" /><br/>
            <input type="button" class="button button-xsmall" value="Crop"
                onclick="cropToSelection();" /><br/>
            <input type="button" class="button button-xsmall" value="Save as..."
                onclick="saveToFile();" />
        </div>
        <div class="buttonGroup">
            <input type="button" class="button button-xsmall" value="New GUID"
                onclick="generate(gens.generateGuid);" title="Generate new GUID/UUID" /><br/>
            <input type="button" class="button button-xsmall" value="ISO DateTime"
                onclick="generate(gens.isoDateTime);" /><br/>
            <input type="button" class="button button-xsmall" value="Epoch"
                onclick="generate(gens.epoch);" />
        </div>

        <div class="buttonGroup settingsGroup">
            <label>Random text</label><br />
            <input id="rndStringLength" type="range" min="1" max="256" value="10"
                style="width: 350px;"
                oninput="adjustRndStringSlider(this); stopRndChangeEvent = true; rndStringLengthNumberInput.value = value; generate(gens.randomString, { loadParams: getRandomStringParams });"
                onclick="adjustRndStringSlider(this); if(stopRndChangeEvent == true) { stopRndChangeEvent = false; } else { generate(gens.randomString, { loadParams: getRandomStringParams }); }" />
            <input id="rndStringLengthNumberInput" type="number" min="1" max="256" value="10" style="width: 50px;" onchange="rndStringLength.value = value; rndStringLength.click()"/><br />
            <label class="off-on">
                <input id="rndLower" type="checkbox" checked
                onchange="generate(gens.randomString, { loadParams: getRandomStringParams });"/>
                <span class="off-on-slider round"></span>
            </label><label for="rndLower">Alpha lowercase</label><br />

            <label class="off-on">
                <input id="rndUpper" type="checkbox" checked
                onchange="generate(gens.randomString, { loadParams: getRandomStringParams });"/>
                <span class="off-on-slider round"></span>
            </label><label for="rndUpper">Alpha UPPERCASE</label><br />
            
            <label class="off-on">
                <input id="rndDigits" type="checkbox" checked
                onchange="generate(gens.randomString, { loadParams: getRandomStringParams });"/>
                <span class="off-on-slider round"></span>
            </label><label for="rndDigits">Digits</label><br />

            <label class="off-on">
                <input id="rndSpecial" type="checkbox"
                onchange="rndSpecialChanged(event); generate(gens.randomString, { loadParams: getRandomStringParams });"/>
                <span class="off-on-slider round"></span>
            </label><label for="rndSpecial">Special</label>&nbsp;
            <input id="rndSpecialChars" type="text" value="[\]^_!&quot;#$%&amp;'()*+,-./`:;&lt;=&gt;?{|}~"
                pattern="[\[\\\]\^_!&quot;#\$%&amp;'\(\)\*\+,-\.\/`:;&lt;=&gt;\?\{\|\}~]+" size="31"
                placeholder="Special chars" disabled
                onchange="generate(gens.randomString, { loadParams: getRandomStringParams });" />
            <!--onkeyup for rndSpecialChars defined on page load-->
        </div>

        <div class="buttonGroup">
            <input type="text" id="replaceValue" placeholder="To replace..." style="margin: 4px 2px;" /><br/>
            <input type="text" id="replaceWith" placeholder="Replace with..." style="margin: 4px 2px;" /><br/>
            <input type="button" class="button button-xsmall" value="Replace"
                onclick="transform(trs.replace, {'isRegex': isReplaceRegex, 'replaceValue': getReplaceValue, 'replaceWith': getReplaceWith, 'all': getReplaceAll, 'caseSensitive': getReplaceCaseSensitive });" /><br/>
            <label class="off-on">
                <input id="replaceAll" type="checkbox" checked />
                <span class="off-on-slider round"></span>
            </label><label for="replaceAll">Replace all</label><br/>
            <label class="off-on">
                <input id="replaceRegex" type="checkbox" />
                <span class="off-on-slider round"></span>
            </label><label for="replaceRegex">Use RegEx</label><br/>
            <label class="off-on">
                <input id="replaceCaseSensitive" type="checkbox" checked />
                <span class="off-on-slider round"></span>
            </label><label for="replaceCaseSensitive">Case sensitive</label><br/>
            <label class="off-on">
                <input id="replaceEscaped" type="checkbox" />
                <span class="off-on-slider round"></span>
            </label><label for="replaceEscaped">Replace escaped</label>
        </div>
    </div>
    <hr />

    <h4>Mode</h4>
    <label class="switch">
        <input type="checkbox" id="cbCopy">
        <span class="slider round slider-copy"></span>
    </label>
    
    <label class="switch" style="display: none;">
        <input type="checkbox" id="cbSelection">
        <span class="slider round slider-selection"></span>
    </label>
    
    <label class="switch">
        <input type="checkbox" id="cbWrap" onchange="setWrap()">
        <span class="slider round slider-wrap"></span>
    </label>

    <div class="buttonGroup">
        <select id="selectionMode" class="button round">
            <option value="allText">All Text</option>
            <option value="selection">Selection</option>
            <option value="lines">Lines</option>
        </select>
    </div>

    <div id="message"
        style="position: fixed; left: 10px;bottom: 10px;right: 10px;z-index: 1000;background: blanchedalmond;color: #909090;display: none;align-items: center;">
        <strong id="messageType" style="padding: 10px;float: left;">Info</strong>
        <span id="messageText" style="padding: 3px;">.</span>
    </div>

    <div class="sidebar">
        <div onclick="this.parentElement.classList.toggle('sidebarExpanded');" style="writing-mode: vertical-rl;user-select: none;border-right: 20px solid #ccc;border-bottom: 15px solid transparent;border-top: 15px solid transparent;
        width: 0px;height: 62px;" onclick=""><span style="position: absolute;right: 0px;letter-spacing: 2px;color: black;">History</span></div>

        <div id="historyItems" class="sidebarBody">
        </div>
        <!-- ...Preview... TODO [Set] [Insert] [Remove] -->
    </div>
    

    <!--TODO add json tree viewer-->
    
</body>

</html>
