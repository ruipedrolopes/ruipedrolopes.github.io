<!DOCTYPE html>
<html>
<head>
    <title>Dencoder Unit Tests</title>
    <meta charset="UTF-8">
    <style>
        body { font-family: sans-serif; background: #202020; color: #ececec; margin: 40px; }
        h1 { color: orange; }
        .summary { font-size: 1.2rem; margin-bottom: 20px; padding: 10px; border-radius: 4px; }
        .summary.pass { background: #1b4d1b; color: #7cfc00; }
        .summary.fail { background: #4d1b1b; color: #ff6347; }
        table { width: 100%; border-collapse: collapse; margin-top: 20px; table-layout: fixed; }
        th, td { text-align: left; padding: 12px; border-bottom: 1px solid #444; vertical-align: top; }
        th { background: #333; position: sticky; top: 0; z-index: 10; }
        tr:hover { background: #2a2a2a; }
        .status-pass { color: #7cfc00; font-weight: bold; }
        .status-fail { color: #ff6347; font-weight: bold; }
        .status-crash { color: #ff00ff; font-weight: bold; background: rgba(255,0,255,0.1); padding: 2px; border-radius: 2px; }
        pre {
            background: #111;
            padding: 5px;
            border-radius: 3px;
            font-size: 0.85rem;
            margin: 0;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
        }
        .hidden { display: none; }
        
        /* Column Widths */
        th:nth-child(1) { width: 15%; } /* Variant */
        th:nth-child(2) { width: 25%; } /* Input */
        th:nth-child(3) { width: 25%; } /* Expected */
        th:nth-child(4) { width: 25%; } /* Actual */
        th:nth-child(5) { width: 10%; } /* Status */

        /* Grouping Styles */
        tr.category-header th { background: #444; color: orange; font-size: 1.1em; text-align: left; padding-top: 20px; padding-left: 12px; }
        tr.feature-header th { background: #333; color: #ccc; padding-left: 24px; font-style: italic; font-weight: normal; }
        tr.test-row td:first-child { padding-left: 48px; color: #aaa; }
    </style>
</head>
<body>

    <h1>Dencoder Unit Tests</h1>
    <div id="summary" class="summary">Loading tests...</div>

    <table>
        <thead>
            <tr>
                <th>Test Case</th>
                <th>Input</th>
                <th>Expected</th>
                <th>Actual</th>
                <th>Status</th>
            </tr>
        </thead>
        <tbody id="testResults"></tbody>
    </table>

    <!-- Mock elements required by dencode.html logic -->
    <div class="hidden">
        <textarea id="value"></textarea>
        <div id="message"><span id="messageType"></span><span id="messageText"></span></div>
        <div id="historyItems"></div>
        <input type="checkbox" id="useTabs">
        <input type="checkbox" id="xmlSafe" checked>
        <input type="checkbox" id="sortDescending">
        <select id="formattingLang"></select>
        <select id="selectionMode"></select>
        <input type="checkbox" id="cbCopy">
    </div>

    <script>
        // 1. Mock standard UI functions to prevent errors during logic execution
        window.getValueElement = () => document.getElementById('value');
        window.flashValue = () => {};
        window.fetchData = () => {};
        window.updateDetectedFormatDisplay = () => {};
        window.initHistory = () => {};
        window.formatWhitepacePadding = () => '  ';
        
        async function runSuite() {
            try {
                // 2. Fetch dencode.html
                const response = await fetch('dencode.html');
                const html = await response.text();
                
                // 3. Extract and execute scripts
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const scripts = doc.querySelectorAll('script');
                
                // Concatenate all script content
                let scriptContent = "";
                scripts.forEach(s => scriptContent += s.textContent + "\n");

                // Execute logic. trs, gens, auxiliary should become available globally.
                const scriptEl = document.createElement('script');
                scriptEl.textContent = scriptContent;
                document.head.appendChild(scriptEl);

                // Start testing
                await executeTests();
            } catch (e) {
                document.getElementById('summary').innerText = "Error loading dencode.html: " + e.message;
                document.getElementById('summary').className = "summary fail";
            }
        }

        const results = [];
        // Deep comparison for objects/arrays
        function deepCompare(a, b) {
            if (a === b) return true;
            if (typeof a !== typeof b) return false;
            if (a && b && typeof a === 'object') {
                if (Array.isArray(a)) {
                    if (a.length !== b.length) return false;
                    for (let i = 0; i < a.length; i++) if (!deepCompare(a[i], b[i])) return false;
                    return true;
                }
                const keysA = Object.keys(a), keysB = Object.keys(b);
                if (keysA.length !== keysB.length) return false;
                for (const key of keysA) if (!deepCompare(a[key], b[key])) return false;
                return true;
            }
            return false;
        }

        // Refactored assert to be resilient
        async function assert(category, feature, variant, input, expected, testFn) {
            let actual;
            let passed = false;
            let crashed = false;
            try {
                actual = await testFn();
                passed = (typeof expected === 'object' && expected !== null) 
                    ? deepCompare(actual, expected) 
                    : actual === expected;
            } catch (e) {
                actual = "[CRASH] " + e.message;
                passed = false;
                crashed = true;
            }
            results.push({ category, feature, variant, input, actual, expected, passed, crashed });
        }

        async function executeTests() {
            const container = document.getElementById('testResults');
            container.innerHTML = "";
            results.length = 0;
            
            // --- DATA SETS ---
            const simpleObj = { a: 1 };
            const complexObj = {
                string: "Hello World! @#$%^&*()",
                number: -123.456,
                boolean: true,
                empty: null,
                array: [1, "two", { nested: true }, [4, 5]],
                object: { a: 1, b: { c: 2 } },
                multiline: "Line 1\nLine 2\nLine 3"
            };
            const simpleJson = JSON.stringify(simpleObj);
            const complexJson = JSON.stringify(complexObj);
            const complexYaml = auxiliary.objectToYaml(complexObj);
            const expectedRoundtrip = JSON.parse(JSON.stringify(complexObj));

            // --- TEST CASES ---

            // Category 1: Selection & Line Modes
            await assert("Modes", "Selection Mode", "Partial UPPER", "abc def", "BC D", async () => {
                const el = getValueElement();
                el.value = "abc def";
                window.cursorPos = { start: 1, end: 5 }; // "bc d"
                document.getElementById('selectionMode').value = "selection";
                document.getElementById('cbCopy').checked = false;
                let result;
                window.displayResult = (r) => { result = r; };
                await transform(trs.toUpperCase);
                return result;
            });

            await assert("Modes", "Lines Mode", "Per-line URL", "a b\nc d", "a%20b\nc%20d", async () => {
                getValueElement().value = "a b\nc d";
                document.getElementById('selectionMode').value = "lines";
                let result;
                window.displayResult = (r) => { result = r; };
                await transform(trs.urlencode);
                return result;
            });

            // Auxiliary
            await assert("Auxiliary", "isBase64", "Valid simple", "SGVsbG8=", true, () => auxiliary.isBase64("SGVsbG8="));
            await assert("Auxiliary", "isBase64", "Invalid chars", "Not Base64!", false, () => auxiliary.isBase64("Not Base64!"));
            await assert("Auxiliary", "isBase64", "With + and /", "abc+", true, () => auxiliary.isBase64("abc+")); 
            await assert("Auxiliary", "isBase64", "Invalid length", "abc", false, () => auxiliary.isBase64("abc"));
            await assert("Auxiliary", "isBase64", "Padding check", "SGVsbG8=", true, () => auxiliary.isBase64("SGVsbG8="));

            await assert("Auxiliary", "isHex", "Valid lowercase", "deadbeef", true, () => auxiliary.isHex("deadbeef"));
            await assert("Auxiliary", "isHex", "Valid uppercase", "DEADBEEF", true, () => auxiliary.isHex("DEADBEEF"));
            await assert("Auxiliary", "isHex", "Invalid chars", "zzzz", false, () => auxiliary.isHex("zzzz"));
            await assert("Auxiliary", "isHex", "Odd length", "ABC", false, () => auxiliary.isHex("ABC"));

            await assert("Auxiliary", "isJson", "Simple object", simpleJson, true, () => auxiliary.isJson(simpleJson).valid);
            await assert("Auxiliary", "isJson", "Complex object", complexJson, true, () => auxiliary.isJson(complexJson).valid);
            await assert("Auxiliary", "isJson", "Invalid", "not json", false, () => auxiliary.isJson("not json"));

            await assert("Auxiliary", "isXml", "Valid simple", "<root/>", true, () => auxiliary.isXml("<root/>"));
            await assert("Auxiliary", "isXml", "Complex with attrs", '<root id="1">text<child/></root>', true, () => auxiliary.isXml('<root id="1">text<child/></root>'));
            await assert("Auxiliary", "isXml", "Invalid", "<root", "object", () => typeof auxiliary.isXml("<root"));

            await assert("Auxiliary", "isYaml", "Simple indicator", "key: value", true, () => auxiliary.isYaml("key: value"));
            await assert("Auxiliary", "isYaml", "List indicator", "- item", true, () => auxiliary.isYaml("- item"));
            
            const yamlLiteral = "multiline: |\n  Line 1\n  Line 2";
            await assert("Auxiliary", "isYaml", "Literal Block (|)", yamlLiteral, {multiline: "Line 1\nLine 2"}, () => auxiliary.yamlToObject(yamlLiteral));
            
            const yamlFolded = "multiline: >\n  Line 1\n  Line 2";
            await assert("Auxiliary", "isYaml", "Folded Block (>)", yamlFolded, {multiline: "Line 1 Line 2"}, () => auxiliary.yamlToObject(yamlFolded));
            
            const yamlQuoted = 'multiline: "Line 1\\nLine 2"';
            await assert("Auxiliary", "isYaml", "Double Quoted", yamlQuoted, {multiline: "Line 1\nLine 2"}, () => auxiliary.yamlToObject(yamlQuoted));
            
            const yamlSimple = "key: value\nlist:\n  - item1\n  - item2";
            await assert("Auxiliary", "isYaml", "No Multiline", yamlSimple, {key: "value", list: ["item1", "item2"]}, () => auxiliary.yamlToObject(yamlSimple));

            const complexValidYaml = [
                'string: "Hello World! @#$%^&*()"',
                'number: -123.456',
                'boolean: true',
                'empty: null',
                'array:',
                '  - 1',
                '  - "two"',
                '  - nested: true',
                '  - - 4',
                '    - 5',
                'object:',
                '  a: 1',
                '  b:',
                '    c: 2',
                'multiline: |',
                '  Line 1',
                '  Line 2',
                '  Line 3'
            ].join('\n');
            
            await assert("Auxiliary", "isYaml", "Complex Valid YAML", complexValidYaml, complexObj, () => auxiliary.yamlToObject(complexValidYaml));

            const uuid = auxiliary.uuidv4();
            await assert("Auxiliary", "uuidv4", "Format check", uuid, true, () => /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i.test(uuid));

            // Transformers
            
            // URL
            await assert("Transformers", "URL Encode", "Basic", "hello world", "hello%20world", () => trs.urlencode("hello world"));
            await assert("Transformers", "URL Encode", "Complex chars", "a + b & c = d?", "a%20%2B%20b%20%26%20c%20%3D%20d%3F", () => trs.urlencode("a + b & c = d?"));
            await assert("Transformers", "URL Decode", "Basic", "hello%20world", "hello world", () => trs.urldecode("hello%20world"));
            await assert("Transformers", "URL Decode", "Complex chars", "a%20%2B%20b%20%26%20c%20%3D%20d%3F", "a + b & c = d?", () => trs.urldecode("a%20%2B%20b%20%26%20c%20%3D%20d%3F"));

            // Base64
            await assert("Transformers", "Base64 Encode", "Simple", "Hello", "SGVsbG8=", () => trs.base64encode("Hello"));
            await assert("Transformers", "Base64 Encode", "UTF-8 Symbols", "Hello! \u20ac100", "SGVsbG8hIOKCrDEwMA==", () => trs.base64encode("Hello! \u20ac100"));
            await assert("Transformers", "Base64 Encode", "UTF-8 Acute", "Ol\u00e1", "T2zDoQ==", () => trs.base64encode("Ol\u00e1"));
            await assert("Transformers", "Base64 Decode", "UTF-8 Acute", "T2zDoQ==", "Ol\u00e1", () => trs.base64decode("T2zDoQ=="));
            await assert("Transformers", "Base64 Decode", "UTF-8 Grave", "T2zDoA==", "Ol\u00e0", () => trs.base64decode("T2zDoA=="));

            // Hex
            await assert("Transformers", "Hex Encode", "Simple", "ABC", "414243", () => trs.hexencode("ABC"));
            await assert("Transformers", "Hex Encode", "Special", "\n\t", "0a09", () => trs.hexencode("\n\t"));
            await assert("Transformers", "Hex Decode", "Simple", "414243", "ABC", () => trs.hexdecode("414243"));

            // HTML
            await assert("Transformers", "HTML Encode", "Simple tag", "<div>", "&lt;div&gt;", () => trs.htmlencode("<div>"));
            await assert("Transformers", "HTML Encode 2", "Entities & Symbols", "\u00e1 \u00a9 \u00ae", "&aacute; &#x00a9; &#x00ae;", () => trs.htmlencode2("\u00e1 \u00a9 \u00ae", {xmlSafe: () => false}));
            await assert("Transformers", "HTML Encode 2", "XML Safe", "\u00e1", "&#x00e1;", () => trs.htmlencode2("\u00e1", {xmlSafe: () => true}));
            await assert("Transformers", "HTML Decode", "Complex", "&lt;div class=\"test\"&gt;&amp;&lt;/div&gt;", "<div class=\"test\">&</div>", () => trs.htmldecode("&lt;div class=\"test\"&gt;&amp;&lt;/div&gt;"));
            
            // Original C-Like Tests
            const complexEscapeInput = 'Line 1\nLine 2\t"Quote" \\Backslash\\' ;
            const complexEscapeExpected = 'Line 1\\nLine 2\\t\\\"Quote\\" \\\\Backslash\\\\' ;
            
            await assert("Transformers", "C-Like Escape", "Simple", 'A"B', 'A\\"B', () => trs.CLikeLang_StringEscape('A"B'));
            await assert("Transformers", "C-Like Escape", "Complex", complexEscapeInput, complexEscapeExpected, () => trs.CLikeLang_StringEscape(complexEscapeInput));
            await assert("Transformers", "C-Like Unescape", "Complex", complexEscapeExpected, complexEscapeInput, () => trs.CLikeLang_StringUnescape(complexEscapeExpected));
            
            // Category 4: UI Utilities
            await assert("Transformers", "Case Conversion", "UPPER", "abc", "ABC", () => trs.toUpperCase("abc"));
            await assert("Transformers", "Case Conversion", "lower", "ABC", "abc", () => trs.toLowerCase("ABC"));

            // C-Type Formatting
            const cTypeExpected = '"Line 1\\n"\n+ "Line 2\\t\\"Quote\\" \\\\Backslash\\\\"';
            await assert("Transformers", "C-Type Stringify", "Simple", "A", '"A"', () => trs.CTypeLang_Stringify("A"));
            await assert("Transformers", "C-Type Stringify", "Multi-line with tabs", complexEscapeInput, cTypeExpected, () => trs.CTypeLang_Stringify(complexEscapeInput));

            // Pretty/Minify
            await assert("Transformers", "Pretty Print", "JSON Simple", simpleJson, JSON.stringify(simpleObj, null, '  '), () => trs.prettyPrint(simpleJson, {getPadding:()=>'  ', getFormatingLang:()=>'JSON'}));
            await assert("Transformers", "Pretty Print", "JSON Complex", complexJson, JSON.stringify(complexObj, null, '  '), () => trs.prettyPrint(complexJson, {getPadding:()=>'  ', getFormatingLang:()=>'JSON'}));
            await assert("Transformers", "Minify", "JSON Complex", JSON.stringify(complexObj, null, 4), complexJson, () => trs.minify(JSON.stringify(complexObj, null, 4), {getFormatingLang:()=>'JSON'}));
            await assert("Transformers", "Pretty Print", "XML Simple", "<root><child/></root>", '<root>\n  <child/>\n</root>', () => trs.prettyPrint("<root><child/></root>", {getPadding:()=>'  ', getFormatingLang:()=>'XML'}));
            
            const simpleYamlInput = "a: 1\nb: 2";
            const simpleYamlExpected = "a: 1\nb: 2";
            await assert("Transformers", "Pretty Print", "YAML Simple", simpleYamlInput, simpleYamlExpected, () => trs.prettyPrint(simpleYamlInput, {getPadding:()=>'  ', getFormatingLang:()=>'YAML'}));

            // Replicate
            await assert("Transformers", "Replicate", "Simple", "A", "AA", () => trs.replicate("A", {getReplicateMode:()=>"simple"}));
            await assert("Transformers", "Replicate", "Template", "ID: ##", "ID: AID: B", () => trs.replicate("ID: ##", {
                getReplicateMode:()=>"template", getReplicatePlaceholder:()=>"##", getReplicateTemplateItems:()=>["A", "B"]
            }));
            await assert("Transformers", "Replicate", "Range", "## ", "1 2 3 ", () => trs.replicate("## ", {
                getReplicateMode:()=>"range", getReplicatePlaceholder:()=>"##", getReplicateRangeStart:()=>1, getReplicateRangeEnd:()=>3
            }));

            // Sort
            await assert("Transformers", "Sort", "Simple", "b\na", "a\nb", () => trs.sort("b\na", {isAscending:()=>true}));
            await assert("Transformers", "Sort", "Case & Numbers", "b\n1\na\n2", "1\n2\na\nb", () => trs.sort("b\n1\na\n2", {isAscending:()=>true}));
            await assert("Transformers", "Sort JSON", "Keys Asc", '{"b":1,"a":2}', '{"a":2,"b":1}', () => trs.sortObject('{"b":1,"a":2}', {isAscending:()=>true, getPadding:()=>''}));
            await assert("Transformers", "Sort JSON", "Keys Desc", '{"a":1,"b":2}', '{"b":2,"a":1}', () => trs.sortObject('{"a":1,"b":2}', {isAscending:()=>false, getPadding:()=>''}));

            // Replace
            await assert("Transformers", "Replace", "Simple All", "line 1", "row 1", () => {
                window.getReplaceValue = () => "line"; window.getReplaceWith = () => "row"; window.getReplaceAll = () => true;
                window.getReplaceCaseSensitive = () => false; window.isReplaceRegex = () => false;
                window.getReplaceEscaped = () => false;
                return trs.replace("line 1");
            });
            
            await assert("Transformers", "Replace", "RegEx Backref", "aa bb cc", "a b c", () => {
                window.getReplaceValue = () => "([a-z])\\1"; window.getReplaceWith = () => "$1"; window.getReplaceAll = () => true;
                window.isReplaceRegex = () => true;
                return trs.replace("aa bb cc");
            });

            await assert("Transformers", "Replace", "Escaped Replacement", "tab", "\t", () => {
                window.getReplaceValue = () => "tab"; window.getReplaceWith = () => "\t"; window.getReplaceAll = () => true;
                window.isReplaceRegex = () => false;
                window.getReplaceEscaped = () => true;
                return trs.replace("tab");
            });

            // Category 2: Transformer Variants
            await assert("Transformers", "Compress", "Deflate", "hello", "string", async () => {
                const compressed = await trs.compress("hello", {compressAlgorithm:()=>"deflate"});
                return typeof compressed;
            });
            await assert("Transformers", "Compress", "Deflate Raw", "hello", "string", async () => {
                const compressed = await trs.compress("hello", {compressAlgorithm:()=>"deflate-raw"});
                return typeof compressed;
            });
            // Category 2: Transformer Variants
            await assert("Transformers", "Digest", "SHA-256 Hex", "hello", "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824", async () => {
                return await trs.digest("hello", {digestAlgorithm:()=>"SHA-256", digestOutputFormat:()=>"hex"});
            });
            await assert("Transformers", "Digest", "SHA-1 Base64", "hello", "qvTGHdzF6KLavt4PO0gs2a6pQ00=", async () => {
                return await trs.digest("hello", {digestAlgorithm:()=>"SHA-1", digestOutputFormat:()=>"base64"});
            });
            await assert("Transformers", "Digest", "SHA-384 Base64", "hello", "string", async () => {
                const hash = await trs.digest("hello", {digestAlgorithm:()=>"SHA-384", digestOutputFormat:()=>"base64"});
                return typeof hash === "string" && hash.length > 20;
            });
            await assert("Transformers", "Digest", "SHA-512 Hex", "hello", "string", async () => {
                const hash = await trs.digest("hello", {digestAlgorithm:()=>"SHA-512", digestOutputFormat:()=>"hex"});
                return typeof hash === "string" && hash.length === 128;
            });

            await assert("Transformers", "Compress", "Deflate", "hello", "string", async () => {
                const compressed = await trs.compress("hello", {compressAlgorithm:()=>"deflate"});
                return typeof compressed;
            });
            await assert("Transformers", "Compress", "Deflate Raw", "hello", "string", async () => {
                const compressed = await trs.compress("hello", {compressAlgorithm:()=>"deflate-raw"});
                return typeof compressed;
            });

            // Category 3: Generators
            await assert("Generators", "Epoch", "Type check", "(current time)", "string", () => typeof gens.epoch());
            await assert("Generators", "ISO DateTime", "Format check", "(now)", true, () => /\d{4}-\d{2}-\d{2}T/.test(gens.isoDateTime()));
            await assert("Generators", "Random String", "Simple Lower", "length 5", true, () => {
                const rnd = gens.randomString({loadParams:()=>({length:5, lower:true, upper:false, digits:false, special:false})});
                return rnd.length === 5 && /^[a-z]+$/.test(rnd);
            });

            // --- RENDER RESULTS ---
            let passedCount = 0;
            let crashCount = 0;
            
            // Group by Category -> Feature
            const grouped = {};
            results.forEach(res => {
                if (!grouped[res.category]) grouped[res.category] = {};
                if (!grouped[res.category][res.feature]) grouped[res.category][res.feature] = [];
                grouped[res.category][res.feature].push(res);
            });

            for (const category in grouped) {
                // Category Header
                const catRow = document.createElement('tr');
                catRow.className = "category-header";
                catRow.innerHTML = `<th colspan="5">${category}</th>`;
                container.appendChild(catRow);

                for (const feature in grouped[category]) {
                    // Feature Header
                    const featRow = document.createElement('tr');
                    featRow.className = "feature-header";
                    featRow.innerHTML = `<th colspan="5">${feature}</th>`;
                    container.appendChild(featRow);

                    grouped[category][feature].forEach(res => {
                        if (res.passed) passedCount++;
                        if (res.crashed) crashCount++;
                        
                        const tr = document.createElement('tr');
                        tr.className = "test-row";
                        
                        let statusClass = res.passed ? 'status-pass' : 'status-fail';
                        let statusText = res.passed ? 'PASS' : 'FAIL';
                        if (res.crashed) {
                            statusClass = 'status-crash';
                            statusText = 'CRASH';
                        }

                        // Stringify objects for display
                        const displayActual = (typeof res.actual === 'object' && res.actual !== null) ? JSON.stringify(res.actual, null, 2) : String(res.actual);
                        const displayExpected = (typeof res.expected === 'object' && res.expected !== null) ? JSON.stringify(res.expected, null, 2) : String(res.expected);

                        tr.innerHTML = `
                            <td>${res.variant}</td>
                            <td><pre>${escape(String(res.input))}</pre></td>
                            <td><pre>${escape(displayExpected)}</pre></td>
                            <td><pre>${escape(displayActual)}</pre></td>
                            <td class="${statusClass}">${statusText}</td>
                        `;
                        container.appendChild(tr);
                    });
                }
            }

            const summary = document.getElementById('summary');
            summary.innerText = `${passedCount} / ${results.length} Tests Passed` + (crashCount > 0 ? ` (${crashCount} CRASHED)` : "");
            summary.className = "summary " + (passedCount === results.length ? "pass" : "fail");
        }

        function escape(str) {
            return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }

        runSuite();
    </script>
</body>
</html>
