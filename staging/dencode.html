<html>

<head>
    <title>DENCODER</title>
    <link rel="icon" type="image/svg+xml"
        href="data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4KPHN2ZyB2aWV3Qm94PSIxMjQuODkyIDE0NC43MDcgMjAwLjMxIDEwNi4wMDkiIHdpZHRoPSIyMDAuMzEiIGhlaWdodD0iMTA2LjAwOSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczpieD0iaHR0cHM6Ly9ydWlwZWRyb2xvcGVzLmdpdGh1Yi5pbyI+CiAgPGcgc3R5bGU9IiIgdHJhbnNmb3JtPSJtYXRyaXgoMC44NDMxMDksIC0wLjAzNzU3MywgMCwgMS4yMTgwNjgsIDE5LjU5NDQyNSwgLTQzLjUzMTk1NikiPgogICAgPGcgc3R5bGU9IiIgdHJhbnNmb3JtPSJtYXRyaXgoMSwgMCwgMCwgMS4zMjE2NzUsIC05NC4zMzU1MjYsIDc2LjA0NDU3MSkiPgogICAgICA8cmVjdCB4PSIyNDguNzkxIiB5PSI5NC43MTEiIHdpZHRoPSIxNTAuODUyIiBoZWlnaHQ9IjEwLjI3IiBzdHlsZT0ic3Ryb2tlOiByZ2IoMCwgMCwgMCk7IHN0cm9rZS13aWR0aDogMHB4OyBmaWxsOiByZ2IoMjU1LCAyNTUsIDApOyIgdHJhbnNmb3JtPSJtYXRyaXgoMC45OTk5OSwgLTAuMDA0NDc5LCAtMC40MzQzOTMsIDEuMDAxOTU2LCAxNi4wNDIxMTIsIDEwLjQ0OTM0MykiLz4KICAgICAgPHBhdGggZD0iTSAzNjYuMzYzIDM4LjIyNSBMIDM5My4wNTUgMTIwLjA0OSBMIDM2Ni4zNjMgMTIwLjA0OSBMIDM2Ni4zNjMgMzguMjI1IFoiIHN0eWxlPSJzdHJva2U6IHJnYigwLCAwLCAwKTsgc3Ryb2tlLXdpZHRoOiAwcHg7IGZpbGw6IHJnYigyNTUsIDI1NSwgMCk7IiB0cmFuc2Zvcm09Im1hdHJpeCgtMC4zODM5MjYsIDAuOTIzMzY0LCAtMS4wOTI5NjksIDAuMDIzOTg0LCA2MzIuODk0MTA0LCAtMjM3LjY1ODk2NikiIGJ4OnNoYXBlPSJ0cmlhbmdsZSAzNjYuMzYzIDM4LjIyNSAyNi42OTIgODEuODI0IDAgMCAxQDhhMzNkY2U1Ii8+CiAgICA8L2c+CiAgICA8ZyBzdHlsZT0iIiB0cmFuc2Zvcm09Im1hdHJpeCgtMSwgMCwgMCwgLTEuMzIxNjc4LCA1ODEuNzA0NTI5LCAzMzUuMDk3MDQ2KSI+CiAgICAgIDxyZWN0IHg9IjI0OC43OTEiIHk9Ijk0LjcxMSIgd2lkdGg9IjE1MC44NTIiIGhlaWdodD0iMTAuMjciIHN0eWxlPSJzdHJva2U6IHJnYigwLCAwLCAwKTsgc3Ryb2tlLXdpZHRoOiAwcHg7IGZpbGw6IHJnYigwLCAxNzQsIDI1NSk7IiB0cmFuc2Zvcm09Im1hdHJpeCgwLjk5OTk5LCAtMC4wMDQ0NzksIC0wLjQzNDM5MywgMS4wMDE5NTYsIDE2LjA0MjExMiwgMTAuNDQ5MzQzKSIvPgogICAgICA8cGF0aCBkPSJNIDM2Ni4zNjMgMzguMjI1IEwgMzkzLjA1NSAxMjAuMDQ5IEwgMzY2LjM2MyAxMjAuMDQ5IEwgMzY2LjM2MyAzOC4yMjUgWiIgc3R5bGU9InN0cm9rZTogcmdiKDAsIDAsIDApOyBzdHJva2Utd2lkdGg6IDBweDsgZmlsbDogcmdiKDAsIDE3NCwgMjU1KTsiIHRyYW5zZm9ybT0ibWF0cml4KC0wLjM4MzkyNiwgMC45MjMzNjQsIC0xLjA5Mjk2OSwgMC4wMjM5ODQsIDYzMi44OTQxMDQsIC0yMzcuNjU4OTY2KSIgYng6c2hhcGU9InRyaWFuZ2xlIDM2Ni4zNjMgMzguMjI1IDI2LjY5MiA4MS44MjQgMCAwIDFAOGEzM2RjZTUiLz4KICAgIDwvZz4KICA8L2c+Cjwvc3ZnPg==">
    <meta charset="UTF-8"/>
    <!-- General -->
    <style>
        body {
            margin: 20px;
            font-family: sans-serif;
            background-color: #353535;
            color: silver;
        }

        input {
            background-color: darkgray;
            border-radius: 4pt
        }

        textarea {
            width: 100%;
            height: 50%;
            max-width: 100%;
            background-color: rgb(36, 36, 36);
            color: silver;
            caret-color: orange;
        }

        textarea::selection {
            color: #101010;
            background-color: darkgray;
        }

        .buttonGroup,
        .checkAlign {
            display: inline-block;
            vertical-align: top;
        }

        .settingsGroup {
            padding-left: 5px;
        }
        
        .settingsGroup>label {
            line-height: 30px;
        }

        .buttonGroup>label {
            user-select: none;
        }

        input[type=checkbox] {
            margin: revert;
        }

        input[type=text], input[type=number], input[type=password] {
            font-family: monospace;
            background-color: rgb(36, 36, 36);
            color: silver;
            margin: revert;
        }

        input[type=number] {
            width: 50px;
        }

        input[type=range] {
            margin: revert;
        }

        .historyItem {
            height: 100px;
            font-size: small;
            border-bottom: solid 3px;
            overflow: hidden;
            white-space: nowrap;
            background-color: #242424;
            color: #ccc;
            font-family: monospace;
            user-select: none;
            padding: 2px;
        }

        .sidebar {
            position: absolute; top: 0px; bottom: 0px; right: 0px;
        }

        .sidebarExpanded {
            right: 203px;
        }

        .sidebarExpanded .sidebarBody {
            display: block !important;
        }

        .sidebar .sidebarBody {
            position: absolute;
            top: 0px;
            left: 20px;
            width: 200px;
            background-color: #ccc;
            bottom: 0px;
            border-left: solid 3px;
            overflow-y: auto;
            display: none;
        }

        hr {
            margin-top: 0.2rem;
            margin-bottom: 0.2rem;
        }

        .nowrap {
            overflow-wrap: anywhere;
            white-space: nowrap;
        }

    </style>
    <!-- Controls -->
    <style>
        .switch {
            color: black;
            position: relative;
            display: inline-block;
            width: 120px;
            height: 30px;
            font-size: 14px;
            font-weight: 500;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
            margin-top: 16px;
        }

        .slider, .off-on-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }

        .slider {
            text-align: center;
        }

        .slider:after, .off-on-slider:after {
            line-height: 30px;
        }

        .off-on-slider:after {
            line-height: 20px;
        }

        .slider:before, .off-on-slider:before {
            position: absolute;
            content: "";
            background-color: white;
            transition: .4s;
        }

        .slider:before {
            height: 22px;
            width: 22px;
            left: 4px;
            bottom: 4px;
            box-shadow: 2px 2px 8px 1px #434343ba;
        }

        .off-on-slider:before {
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            box-shadow: 1px 1px 3px 1px #434343ba;
        }

        input:checked+.slider, input:checked+.off-on-slider {
            background-color: #2196F3;
        }

        input:focus+.slider, input:focus+.off-on-slider {
            box-shadow: 0 0 1px #2196F3;
        }

        input:checked+.slider:before {
            transform: translateX(90px);
        }

        input:checked+.off-on-slider:before {
            transform: translateX(20px);
        }

        .slider.round, .off-on-slider.round {
            border-radius: 30px;
        }

        .off-on-slider.round {
            border-radius: 10px;
        }

        .slider.round:before, .off-on-slider.round:before {
            border-radius: 50%;
        }

        .slider-copy:after { content: "Transform"; }
        input:checked+.slider-copy:after { content: "Copy"; }

        .slider-padding:after { content: "Spaces"; }
        input:checked+.slider-padding:after { content: "Tabs"; }

        .slider-selection:after { content: "All text"; }
        input:checked+.slider-selection:after { content: "Selection"; }
        
        .slider-sort:after { content: "Asc."; }
        input:checked+.slider-sort:after { content: "Desc."; }

        .slider-wrap:after { content: "Wrap"; }
        input:checked+.slider-wrap:after { content: "No wrap"; }

        .button, .buttonGroup > input[type=button], .buttonGroup > select {
            background-color: #ccc;
            border: 2px solid #7c7c7c;
            color: #000000;
            padding: 2px 6px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 14px;
            margin: 4px 2px;
            transition-duration: 0.4s;
            cursor: pointer;
            border-radius: 8px;
            width: 100%;
        }

        .button:hover, .buttonGroup > input[type=button]:hover, .buttonGroup > select:hover {
            background-color: #4d4d4d;
            border: 2px solid #c5c5c5;
            color: white;
        }

        .button:active, .buttonGroup > input[type=button]:active, .buttonGroup > select:active {
            background-color: #2196F3;
            border: 2px solid #7c7c7c;
            color: #000000;
        }

        .button-large {
            padding: 6px 22px;
            font-size: 16px;
        }

        .button.round {
            text-align: left;
            margin: 0;
            padding: 5px 22px;
            border-radius: 30px;
        }

        select:active {
            background-color: unset !important;
        }

        select:hover {
            background-color: #ccc !important;
            color: #000000 !important;
        }

        .off-on {
            width: 40px;
            height: 20px;
            position: relative;
            display: inline-block;
            margin: 5px 0;
        }

        .off-on+label {
            cursor: pointer;
            user-select: none;
        }

        .off-on+label:before {
            content: " ";
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 7px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 5px;
            background-image: linear-gradient(#2196F3, #2196F3);
            background-repeat: no-repeat;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 15px;
            width: 15px;
            border-radius: 50%;
            background: #2196F3;
            cursor: ew-resize;
            box-shadow: 0 0 3px 0 #555;
            transition: background .3s ease-in-out;
        }

        input[type="range"]::-moz-range-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 15px;
            width: 15px;
            border-radius: 50%;
            background: #2196F3;
            cursor: ew-resize;
            box-shadow: 0 0 3px 0 #555;
            transition: background .3s ease-in-out;
        }

        input[type="range"]::-ms-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 15px;
            width: 15px;
            border-radius: 50%;
            background: #2196F3;
            cursor: ew-resize;
            box-shadow: 0 0 3px 0 #555;
            transition: background .3s ease-in-out;
        }

        input[type=range]::-webkit-slider-runnable-track {
            -webkit-appearance: none;
            box-shadow: none;
            border: none;
            background: transparent;
        }

        input[type=range]::-moz-range-track {
            -webkit-appearance: none;
            appearance: none;
            box-shadow: none;
            border: none;
            background: transparent;
        }

        input[type=range]::-ms-track {
            -webkit-appearance: none;
            appearance: none;
            box-shadow: none;
            border: none;
            background: transparent;
        }

        .success-tag {
            font-family: 'Courier New', Courier, monospace;
            background-color: greenyellow;
            color: black;
            font-weight: 600;
            padding: 0.1rem;
            border-radius: 0.2rem;
        }

        .error-tag {
            font-family: 'Courier New', Courier, monospace;
            background-color: tomato;
            color: black;
            font-weight: 600;
            padding: 0.1rem;
            border-radius: 0.2rem;
        }

    </style>
    <script type="text/javascript">

        const el = (tag, props = {}, ...children) => {
            const e = document.createElement(tag);
            Object.entries(props).forEach(([k, v]) => {
                if (k === "class") e.className = v;
                else if (k === "on") Object.entries(v).forEach(([ev, fn]) => e.addEventListener(ev, fn));
                else if (k === "style" && typeof v === "object") Object.assign(e.style, v);
                else e[k] = v;
            });
            const append = (p, c) => {
                if (Array.isArray(c)) c.forEach(n => append(p, n));
                else if (c !== null && c !== undefined && c !== false) p.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
            };
            children.forEach(c => append(e, c));
            return e;
        };

        document.addEventListener("click", (e) => {
            const tr = e.target.dataset.trs;
            if (tr) transform(trs[tr]);
            const gn = e.target.dataset.gens;
            if (gn) generate(gens[gn]);
        });

        window.onload = function () {
            const valueTextArea = getValueElement();
            valueTextArea.onmouseup =
            valueTextArea.onkeyup =
            valueTextArea.ontouchend =
            valueTextArea.onselect =
            valueTextArea.onselectionchange =
            valueTextArea.oninput =
            valueTextArea.onmouseleave = fetchData;
            
            document.getElementById("rndSpecialChars").onkeydown = preventInvalidSpecialChars;
            document.getElementById("rndStringLengthNumberInput").oninput = preventInvalidRndLength;

            adjustRndStringSlider(document.getElementById("rndStringLength"));

            initHistory();

            let lastValue = "";
            function autoDetect() {
                try {
                    const currentValue = getValueElement().value;
                    if (currentValue !== lastValue) {
                        // if modified in the last 1 second return (debounce)
                        if (new Date().getTime() - window.valueTouched.getTime() >= 1000) {
                            lastValue = currentValue;
                            const detected = detectFormatOrLanguage();
                            updateDetectedFormatDisplay(detected);
                        }
                    }
                } catch (e) {
                    console.error("Auto-detect error:", e);
                } finally {
                    window.setTimeout(autoDetect, 1000);
                }
            }
            autoDetect();
        }

        function isAsync(func) {
            return func.constructor.name === "AsyncFunction";
        }

        function getSelectionMode() {
            return document.getElementById("selectionMode").value;
        }

        async function transform(transformer, params) {
            if (typeof transformer != "function") {
                console.warn("Transformer is not a function.");
                return;
            }

            let fullValue = getValueElement().value;
            if (isSelectionMode()) {
                fullValue = fullValue.substr(cursorPos.start, cursorPos.end - cursorPos.start);
            }


            let values = [fullValue];
            if(getSelectionMode() === "lines") {
                values = fullValue.split("\n");
            }
            
            
            const finalResult = await Promise.all(values.map(async (value, index) => {
                try {
                    let result;

                    if(isAsync(transformer)) {
                        result = await transformer(value, params);
                    } else {
                        result = transformer(value, params);
                    }

                    if (typeof result != "string") {

                        // TODO evaluate if this can be deprecated
                        /*if (typeof result == "object" && typeof result.promise == "object" && typeof result.promise.then == "function") {
                            // this has a promise

                            result.promise.then((promiseResult) => {
                                addToHistory();
                                var b64result = auxiliary.arrayBufferToBase64(promiseResult);
                                
                                if(result.finalize) {
                                    displayResult(eval(result.finalize)(b64result));
                                } else {
                                    displayResult(b64result);
                                }
                            });
                            return;
                        }*/

                        console.warn("Transformer returned an invalid value" + (values.length > 1? " at line " + (index + 1): ""));
                        return value;
                    }

                    //addToHistory();

                    //displayResult(result);

                    return result;
                } catch(e) {
                    error("An error occured: " + e, 4000);
                    throw e;
                }
            }));
            
            addToHistory();

            displayResult(finalResult.join("\n"));
            
        }

        function generate(generator, params) {
            if (typeof generator != "function") {
                console.warn("generator is not a function.");
                return;
            }

            try {
                const result = generator(params);

                if (typeof result != "string") {
                    console.warn("Transformer returned an invalid value.");
                    return;
                }

                addToHistory();

                displayResult(result);
            } catch(e) {
                error("An error occured: " + e, 4000);
                throw e;
            }
        }

        function getValueElement() {
            return document.getElementById("value");
        }

        function addToHistory() {
            let value = getValueElement().value;
            
            if(value.length == 0) {
                return;
            }
            
            let history = JSON.parse(sessionStorage.getItem("history")) || [];

            //prevent history filling when changing random size
            if(history.length > 0 && history[history.length-1].t > new Date().valueOf() - 300) {
                return;
            }

            if(history.length > 32) {
                history = history.sort((a, b) => a.t - b.t).splice(1);
            }

            history.push(
                {
                    "v": value,
                    "t": new Date().valueOf()
                });

            refreshHistoryItems(history);
            sessionStorage.setItem("history", JSON.stringify(history));
        }

        function refreshHistoryItems(history) {
            const container = document.getElementById("historyItems");
            container.innerHTML = "";
            history.slice().reverse().forEach((item, i) => {
                container.appendChild(el("div", {
                    class: "historyItem",
                    ondblclick: () => setFromHistory(history.length - 1 - i),
                    innerText: item.v
                }));
            });
        }

        function setFromHistory(index) {
            let history = JSON.parse(sessionStorage.getItem("history"));
            getValueElement().value = history[index].v;
            flashValue();
        }

        function initHistory() {
            if(typeof(sessionStorage.getItem("history")) !== "string") {
                sessionStorage.setItem("history", JSON.stringify([]));
            } else {
                refreshHistoryItems(JSON.parse(sessionStorage.getItem("history")));
            }
        }

        function isSelectionMode() {
            return getSelectionMode() === "selection";
        }

        function isCopyMode() {
            return document.getElementById("cbCopy").checked;
        }

        function flashValue() {
            const valueTextArea = getValueElement();
            const color = valueTextArea.style.backgroundColor;
            valueTextArea.style.backgroundColor = "gray";
            setTimeout(() => { valueTextArea.style.backgroundColor = color; }, 150);
        }

        function displayResult(result) {
            const valueTextArea = getValueElement();
            if (isCopyMode()) {
                flashValue()

                copyToClipboard(result);
            } else {
                if (isSelectionMode()) {
                    const currentValue = valueTextArea.value;
                    let value = currentValue.substr(0, cursorPos.start) + result + currentValue.substr(cursorPos.end, currentValue.length - cursorPos.end);

                    valueTextArea.value = value;

                    valueTextArea.selectionStart = valueTextArea.selectionEnd = cursorPos.start

                    //preventing scroll to bottom on large texts
                    valueTextArea.blur();
                    valueTextArea.focus();
                    cursorPos.end = cursorPos.start + result.length;
                    
                    valueTextArea.setSelectionRange(cursorPos.start, cursorPos.end);

                    valueTextArea.focus();

                } else {
                    valueTextArea.value = result;
                }
            }
        }

        const auxiliary = {
            isValidString: (str) => typeof str === 'string' && str.length > 0,

            uuidv4: function () {
                try {
                    return crypto.randomUUID();
                } catch (e) {
                    //fallback in case of insecure context being used or unavailable
                    console.error(e);
                    return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                        (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
                    );
                }
            },

            utf8ToBase64: function (str) {
                const encoder = new TextEncoder();
                const uint8Array = encoder.encode(str);
                return btoa(String.fromCharCode.apply(null, uint8Array));
            },

            base64ToUtf8: function (base64Str) {
                const binaryString = atob(base64Str);
                const uint8Array = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                    uint8Array[i] = binaryString.charCodeAt(i);
                }
                const decoder = new TextDecoder();
                return decoder.decode(uint8Array);
            },

            // detects if a string is valid JSON, malformed JSON, or not JSON at all.
            // Returns:
            //   - true: if the string is valid JSON.
            //   - false: if the string is not trying to be JSON.
            //   - object: with error details if the string is a malformed JSON.
            isJson: function (str) {
                if (!this.isValidString(str)) {
                    return false;
                }
                // Peek first and last non-whitespace characters
                const startMatch = str.match(/^\s*([{\["\d-]|true|false|null)/);
                if (!startMatch) {
                    return false;
                }

                try {
                    const data = JSON.parse(str);
                    return { valid: true, data: data };
                } catch (e) {
                    // Heuristic to determine if it's a malformed attempt vs. not JSON at all.
                    const firstChar = startMatch[1][0];
                    if (['{', '[', '"'].includes(firstChar) || /^(-|true|false|null)/i.test(startMatch[1]) || (firstChar >= '0' && firstChar <= '9')) {
                        return { name: e.name, message: e.message, exception: e };
                    }
                    return false;
                }
            },

            // detects if a string is valid XML, malformed XML, or not XML at all.
            // Returns:
            //   - true: if the string is well-formed XML.
            //   - false: if the string is not trying to be XML.
            //   - object: with error details if the string is a malformed XML.
            isXml: function (str) {
                if (!this.isValidString(str)) {
                    return false;
                }
                const xmlLikeRegex = /^\s*<(\?|!|(\w)|(\/))/;
                if (!xmlLikeRegex.test(str)) {
                    return false;
                }
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(str, "application/xml");
                const parserError = xmlDoc.querySelector("parsererror");
                if (parserError) {
                    return {
                        name: "XMLParserError",
                        message: parserError.textContent || "Malformed XML",
                        details: parserError
                    };
                }
                return true;
            },

            // detects if a string is Base64 encoded, supporting multi-line input.
            isBase64: function(str) {
                if (!this.isValidString(str)) {
                    return false;
                }
                // Quick check: does it contain non-base64 characters?
                // This is much faster than replace on large strings.
                if (/[^A-Za-z0-9+/=\s]/.test(str)) {
                    return false;
                }
                const cleanStr = str.replace(/\s/g, '');
                if (cleanStr.length === 0 || cleanStr.length % 4 !== 0) {
                    return false;
                }
                const base64Regex = /^[A-Za-z0-9+/]*={0,2}$/;
                return base64Regex.test(cleanStr);
            },

            // detects if a string is Hex encoded, supporting multi-line input.
            isHex: function(str) {
                if (!this.isValidString(str)) {
                    return false;
                }
                // Quick check: does it contain non-hex characters?
                if (/[^0-9a-fA-F\s]/.test(str)) {
                    return false;
                }
                const cleanStr = str.replace(/\s/g, '');
                if (cleanStr.length === 0 || cleanStr.length % 2 !== 0) {
                    return false;
                }
                const hexRegex = /^[0-9a-fA-F]+$/;
                return hexRegex.test(cleanStr);
            },
            
            isYaml: function (str) {
                if (!this.isValidString(str)) {
                    return false;
                }
                // YAML is very broad; we only check a portion to avoid regex hanging on massive strings
                const sample = str.substring(0, 10000);
                const yamlIndicators = [
                    /:\s*$/m,               // key:
                    /^\s*-\s+/m,            // - item
                    /^\s*\w+\s*:\s*.+$/m,   // key: value
                    /^\s*#/,                // comment
                    /^\s*---\s*$/m          // document start
                ];
                for (const regex of yamlIndicators) {
                    if (regex.test(sample)) {
                        return true;
                    }
                }
                return false;
            },

            objectToYaml: function(obj, indentLevel, paddingChar) {
                indentLevel = indentLevel || 0;
                paddingChar = paddingChar || '  ';
                const indent = paddingChar.repeat(indentLevel);
                
                if (obj === null) return 'null';
                if (typeof obj === 'undefined') return '';
                if (typeof obj !== 'object') {
                    if (typeof obj === 'string') {
                        if (obj.includes('\n')) {
                            const blockIndent = paddingChar.repeat(indentLevel + 1);
                            return '|\n' + obj.split('\n').map(l => blockIndent + l).join('\n');
                        }
                        if (obj.includes(':') || obj.includes('#') || obj.trim().length !== obj.length || !isNaN(Number(obj)) || obj === "true" || obj === "false" || obj === "null" || obj === "[]" || obj === "{}") {
                            return JSON.stringify(obj);
                        }
                    }
                    return String(obj);
                }
                
                if (obj instanceof Date) return obj.toISOString();

                let yaml = '';
                
                if (Array.isArray(obj)) {
                    if (obj.length === 0) return '[]';
                    obj.forEach(item => {
                        const itemStr = auxiliary.objectToYaml(item, indentLevel + 1, paddingChar);
                        if (itemStr.startsWith('|') || itemStr.includes('\n')) {
                             yaml += `${indent}- ${itemStr}\n`;
                        } else {
                             yaml += `${indent}- ${itemStr.trim()}\n`;
                        }
                    });
                } else {
                    if (Object.keys(obj).length === 0) return '{}';
                    for (const [key, value] of Object.entries(obj)) {
                        const valStr = auxiliary.objectToYaml(value, indentLevel + 1, paddingChar);
                        
                        const isComplex = typeof value === 'object' && value !== null && !(value instanceof Date);
                        const isMultiline = typeof value === 'string' && value.includes('\n');
                        const isEmpty = isComplex && (Array.isArray(value) ? value.length === 0 : Object.keys(value).length === 0);
                        
                        if ((isComplex && !isEmpty) || isMultiline) {
                            yaml += `${indent}${key}: ${valStr}\n`;
                        } else {
                            yaml += `${indent}${key}: ${valStr.trim()}\n`;
                        }
                    }
                }
                return yaml.trimEnd();
            },

            yamlToObject: function(str) {
                if (!str || !str.trim()) throw new Error("Empty string");

                const linesArr = str.split(/\r?\n/);

                const parseScalar = (v) => {
                    v = v.trim();
                    if (v === 'true') return true;
                    if (v === 'false') return false;
                    if (v === 'null') return null;
                    if (v === '') return null;
                    if (v === '[]') return [];
                    if (v === '{}') return {};
                    
                    if (v.startsWith('"') && v.endsWith('"')) {
                        try { return JSON.parse(v); } catch (e) { return v.slice(1, -1); }
                    }
                    if (v.startsWith("'") && v.endsWith("'")) return v.slice(1, -1);

                    const num = Number(v);
                    if (!isNaN(num) && v.trim() !== "") return num;
                    return v;
                };

                function parseBlock(startIdx, minIndent) {
                    let result = null;
                    let i = startIdx;

                    while (i < linesArr.length) {
                        const line = linesArr[i];
                        if (!line.trim() || line.trim().startsWith('#')) { i++; continue; }

                        const indent = line.search(/\S/);
                        if (indent < minIndent) break;

                        const trimmed = line.trim();

                        if (trimmed.startsWith('-')) {
                            if (result === null) result = [];
                            let content = trimmed.substring(1).trim();
                            
                            if (content === '|' || content === '>') {
                                const mode = content;
                                let blockLines = [];
                                i++;
                                let blockIndent = -1;
                                while (i < linesArr.length) {
                                    if (!linesArr[i].trim()) { blockLines.push(""); i++; continue; }
                                    const nextIndent = linesArr[i].search(/\S/);
                                    if (blockIndent === -1) blockIndent = nextIndent;
                                    if (nextIndent < blockIndent) break;
                                    blockLines.push(linesArr[i].substring(blockIndent));
                                    i++;
                                }
                                result.push(mode === '|' ? blockLines.join('\n') : blockLines.join(' ').trim());
                            } else if (!content) {
                                const sub = parseBlock(i + 1, indent + 1);
                                result.push(sub.data);
                                i = sub.nextIdx;
                            } else {
                                const kv = content.match(/^([^:]+):\s*(.*)$/);
                                const isCompactList = content.startsWith('-');
                                
                                if (kv || isCompactList) {
                                    // Compact sequence or mapping: start a sub-block at the current position
                                    // but we need to pass a string that doesn't have the parent's "-"
                                    const spaces = " ".repeat(line.indexOf('-') + 1);
                                    const virtualLine = spaces + " " + content;
                                    const originalLine = linesArr[i];
                                    linesArr[i] = virtualLine;
                                    const sub = parseBlock(i, indent + 1);
                                    linesArr[i] = originalLine; // restore
                                    result.push(sub.data);
                                    i = sub.nextIdx;
                                } else {
                                    result.push(parseScalar(content));
                                    i++;
                                }
                            }
                        } else {
                            const kv = trimmed.match(/^([^:]+):\s*(.*)$/);
                            if (kv) {
                                if (result === null) result = {};
                                const key = kv[1].trim();
                                let valStr = kv[2].trim();

                                if (valStr === '|' || valStr === '>') {
                                    const mode = valStr;
                                    let blockLines = [];
                                    i++;
                                    let blockIndent = -1;
                                    while (i < linesArr.length) {
                                        if (!linesArr[i].trim()) { blockLines.push(""); i++; continue; }
                                        const nextIndent = linesArr[i].search(/\S/);
                                        if (blockIndent === -1) blockIndent = nextIndent;
                                        if (nextIndent < blockIndent) break;
                                        blockLines.push(linesArr[i].substring(blockIndent));
                                        i++;
                                    }
                                    result[key] = mode === '|' ? blockLines.join('\n') : blockLines.join(' ').trim();
                                } else if (!valStr) {
                                    const sub = parseBlock(i + 1, indent + 1);
                                    result[key] = sub.data;
                                    i = sub.nextIdx;
                                } else {
                                    result[key] = parseScalar(valStr);
                                    i++;
                                }
                            } else {
                                i++;
                            }
                        }
                    }
                    return { data: result, nextIdx: i };
                }

                const parsedResult = parseBlock(0, 0);
                return parsedResult.data || {};
            }
        };

        //Generators
        const gens = (() => {

            //private functions


            //public functions
            return {
                generateGuid: function () {
                    return auxiliary.uuidv4();
                },

                randomString: function (params) {
                    const rndStringParams = params.loadParams();
                    const length = rndStringParams.length;

                    let validTypes = [];

                    if (rndStringParams.lower === true) {
                        validTypes.push((r) => { return String.fromCharCode(r % 26 + 97); });
                    }

                    if (rndStringParams.upper === true) {
                        validTypes.push((r) => { return String.fromCharCode(r % 26 + 65); });
                    }

                    if (rndStringParams.digits === true) {
                        validTypes.push((r) => { return String.fromCharCode(r % 10 + 48); });
                    }

                    if (rndStringParams.special === true && rndStringParams.specialChars.length > 0) {
                        validTypes.push((r) => {
                            const chars = rndStringParams.specialChars;
                            return chars[r % chars.length];
                        });
                    }

                    //[\]^_!"#$%&'()*+,-./`:;<=>?{|}~
                    // escaped: "[\\]^_!\"#$%&\'()*+,-./`:;<=>?{|}~"
                    // pattern: [\[\\\]\^_!"#\$%&'\(\)\*\+,-\.\/`:;<=>\?\{\|\}~]+

                    let result = "";

                    if (validTypes.length > 0) {
                        const types = crypto.getRandomValues(new Uint8Array(length));
                        const chars = crypto.getRandomValues(new Uint8Array(length));

                        for (let i = 0; i < length; i++) {
                            const type = types[i] % validTypes.length;
                            result += validTypes[type](chars[i]);
                        }
                    }

                    return result;
                },


                isoDateTime: function() {
                    return new Date().toISOString();
                },

                epoch: function() {
                    return new Date().valueOf().toString();
                }
                
                //Add more generators here.

            }
        })();


        //Transformers
        const trs = (() => {

            //private functions
            function escapeHtmlChar(original, xmlSafe) {
                const thechar = original.charCodeAt(0);
                const basic = { 60: "&lt;", 62: "&gt;", 34: "&quot;", 38: "&amp;" };
                if (basic[thechar]) return basic[thechar];

                if (!xmlSafe) {
                    const entities = {
                        198: "&AElig;", 193: "&Aacute;", 194: "&Acirc;", 192: "&Agrave;", 197: "&Aring;", 195: "&Atilde;", 196: "&Auml;", 199: "&Ccedil;",
                        208: "&ETH;", 201: "&Eacute;", 202: "&Ecirc;", 200: "&Egrave;", 203: "&Euml;", 205: "&Iacute;", 206: "&Icirc;", 204: "&Igrave;",
                        207: "&Iuml;", 209: "&Ntilde;", 211: "&Oacute;", 212: "&Ocirc;", 210: "&Ograve;", 216: "&Oslash;", 213: "&Otilde;", 214: "&Ouml;",
                        222: "&THORN;", 218: "&Uacute;", 219: "&Ucirc;", 217: "&Ugrave;", 220: "&Uuml;", 221: "&Yacute;", 225: "&aacute;", 226: "&acirc;",
                        230: "&aelig;", 224: "&agrave;", 229: "&aring;", 227: "&atilde;", 228: "&auml;", 231: "&ccedil;", 233: "&eacute;", 234: "&ecirc;",
                        232: "&egrave;", 240: "&eth;", 235: "&euml;", 237: "&iacute;", 238: "&icirc;", 236: "&igrave;", 239: "&iuml;", 241: "&ntilde;",
                        243: "&oacute;", 244: "&ocirc;", 242: "&ograve;", 248: "&oslash;", 245: "&otilde;", 246: "&ouml;", 223: "&szlig;", 254: "&thorn;",
                        250: "&uacute;", 251: "&ucirc;", 249: "&ugrave;", 252: "&uuml;", 253: "&yacute;", 255: "&yuml;", 162: "&cent;"
                    };
                    if (entities[thechar]) return entities[thechar];
                }

                if (thechar > 127) {
                    return "&#x" + thechar.toString(16).padStart(4, "0") + ";";
                }
                return original;
            }

            function encodeChar(original, skipNewLine) {
                if (skipNewLine && original == '\n') return;
                const escapes = { '\n': "\\n", '\r': "\\r", '\'': "\\'", '"': "\\\"", '\\': "\\\\", '\t': "\\t", '\b': "\\b", '\f': "\\f" };
                if (escapes[original]) return escapes[original];

                const thechar = original.charCodeAt(0);
                if (thechar > 127) {
                    return "\\u" + thechar.toString(16).padStart(4, "0");
                }
                return original;
            }

            function xslTransform(source, xslTransformer) {
                const xmlDoc = new DOMParser().parseFromString(source, 'application/xml');
                const xsltDoc = new DOMParser().parseFromString(xslTransformer, 'application/xml');
                const xsltProcessor = new XSLTProcessor();    
                xsltProcessor.importStylesheet(xsltDoc);
                let resultDoc = xsltProcessor.transformToDocument(xmlDoc);
                const result = new XMLSerializer().serializeToString(resultDoc);

                //check for errors
                const resultParser = new DOMParser();
                resultDoc = resultParser.parseFromString(result, "application/xml");

                const errorElem = xmlDoc.getElementsByTagName("parsererror");
                if(errorElem.length > 0) {
                    error("Error parsing value: " + errorElem[0].getElementsByTagName("div")[0].innerHTML, 5000);
                    return source;
                }
                return result;
            }

            const prettifyXml = function(sourceXml, pretty, paddingChars) {

                let resultXml = xslTransform(sourceXml, [
                    // describes how we want to modify the XML - indent everything
                    '<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform">',
                    '  <xsl:strip-space elements="*"/>',
                    '  <xsl:template match="para[content-style][not(text())]">', // change to just text() to strip space in text nodes
                    '    <xsl:value-of select="normalize-space(.)"/>',
                    '  </xsl:template>',
                    '  <xsl:template match="node()|@*">',
                    '    <xsl:copy><xsl:apply-templates select="node()|@*"/></xsl:copy>',
                    '  </xsl:template>',
                    '  <xsl:output indent="' + (pretty? 'yes': 'no') + '"/>',
                    '</xsl:stylesheet>',
                ].join('\n'));

                if(pretty == true) {
                    // Replace indentation 2 spaces with padding chars

                    if(paddingChars !== "  ") {

                        function replacer(match, p1, offset, string) {
                            return match.replaceAll("  ", paddingChars);
                        }
                        resultXml = resultXml.replace(/>\n(\s\s)+</g, replacer);
                    }
                }

                return resultXml;
            };

            function formatXml(xml, pretty, paddingChars) {

                try {
                    return prettifyXml(xml, pretty, paddingChars)
                } catch (e) {
                    console.warn(e);
                    // use fallback code bellow in case of exception
                }

                let formatted = '';
                const reg = /(>)(<)(\/*)/g;
                const paddingStr = paddingChars;
                xml = xml.replace(reg, '$1\r\n$2$3');
                let pad = 0;
                const lines = xml.split('\r\n');
                for (var index = 0; index < lines.length; index++) {
                    const node = lines[index];
                    let indent = 0;
                    if (node.match(/.+<\/\w[^>]*>$/)) {
                        indent = 0;
                    } else if (node.match(/^<\/\w/)) {
                        if (pad != 0) {
                            pad -= 1;
                        }
                    } else if (node.match(/^<\w[^>]*[^\/]>.*$/)) {
                        indent = 1;
                    } else {
                        indent = 0;
                    }

                    let padding = '';
                    for (let i = 0; i < pad; i++) {
                        padding += paddingStr;
                    }

                    formatted += padding + node + '\r\n';
                    pad += indent;
                }
                return formatted;
            }

            function encodeUrlToken(input) {
                const ret = input.replace(/\+/g, "-").replace(/\//g, "_");
                if (ret.length == 0)
                    return "";
                const noPadding = ret.replace(/=+$/, "");
                return noPadding + (ret.length - noPadding.length).toString();
            }

            function decodeUrlToken(input) {
                const ec = parseInt(input.substring(input.length - 1));
                let temp = input.replace(/\-/g, "+").replace(/\_/g, "/");
                temp = temp.substring(0, temp.length - 1);
                return temp + "===".substring(0, ec);
            }

            function indexes(value, toFind, startingAt, found) {
                if(typeof(found) == "undefined") { found = []; }
                if(typeof(startingAt) == "undefined") { startingAt = 0; }

                const idx = value.indexOf(toFind, startingAt);
                
                if(idx == -1) { return found; }

                found.push(idx);
                return indexes(value, toFind, idx + toFind.length, found);
            }

            function sortObject(unordered, sortArrays = false, reverse = false) {
                if (!unordered || typeof unordered !== 'object') {
                    return unordered;
                }

                if (Array.isArray(unordered)) {
                    const newArr = unordered.map((item) => sortObject(item, sortArrays, reverse));
                    if (sortArrays) {
                        newArr.sort();
                        if(reverse === true) {
                            newArr.reverse();
                        }
                    }
                    return newArr;
                }

                const ordered = {};
                const keys = Object.keys(unordered).sort();
                if(reverse === true) {
                    keys.reverse();
                }

                keys.forEach((key) => {
                    ordered[key] = sortObject(unordered[key], sortArrays, reverse);
                });
                return ordered;
            }


            async function collectStream(stream) {
                const reader = stream.getReader();
                let chunks = [];
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) {
                        break;
                    }
                    chunks.push(value);
                }
                return new Uint8Array(await new Blob(chunks).arrayBuffer());
            }

            // public functions
            return {
                urlencode: function (value) {
                    return encodeURIComponent(value);
                },

                urldecode: function (value) {
                    try {
                        return decodeURIComponent(value);
                    }
                    catch (e) {
                        console.error(e);
                        return -1;
                    }
                },

                htmlencode: function (value) {
                    return document.createElement('a').appendChild(
                        document.createTextNode(value)).parentNode.innerHTML;
                },

                htmlencode2: function (value, params) {
                    let result = "";
                    const xmlSafe = params.xmlSafe() == true;

                    for (let i = 0; i < value.length; i++) {
                        result += escapeHtmlChar(value[i], xmlSafe);
                    }

                    return result;
                },

                htmldecode: function (value) {
                    const a = document.createElement('a');
                    a.innerHTML = value;
                    return a.textContent;
                },

                base64encode: function (value) {
                    try {
                        return auxiliary.utf8ToBase64(value);
                    } catch(e) {
                        console.error(e);
                        console.error("Falling back to legacy btoa.");
                        return window.btoa(value);
                    }
                },

                base64decode: function (value) {
                    try {
                        return auxiliary.base64ToUtf8(value);
                    } catch(e) {
                        console.error(e);
                        console.error("Falling back to legacy atob.");
                        try {
                            return window.atob(value);
                        }
                        catch (e) {
                            console.error(e);
                            warn("Invalid base64 text");
                            return -1;
                        }
                    }
                    
                },

                hexencode: function (value) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += '' + value.charCodeAt(i).toString(16).padStart(2, "0");
                    }

                    return hex;
                },

                hexdecode: function (value) {
                    const hex = value;
                    let str = "";
                    for (let i = 0; i < hex.length; i += 2) {
                        str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
                    }

                    return str;
                },

                CLikeLang_StringEscape: function (value) {
                    const preescape = "" + value;
                    let escaped = "";

                    for (let i = 0; i < preescape.length; i++) {
                        escaped = escaped + encodeChar(preescape.charAt(i), false);
                    }

                    return escaped;
                },

                CLikeLang_StringUnescape: function (value) {
                    try {
                        const replacement = `##TEMP##${auxiliary.uuidv4()}##`;
                        const temp = eval(`new String(\'${value.replaceAll("'", replacement)}\')`);
                        return temp.replaceAll(replacement, "'");
                    } catch (error) {
                        console.error(error);
                        warn("Could not unescape. Make sure you have no invalid characters like line breaks.", 5000);
                        return value;
                    }
                },

                prettyPrint: function(value, params) {
                    const padding = params.getPadding();
                    const lang = params.getFormatingLang();
                    switch (lang) {
                        case "JSON":
                            return JSON.stringify(JSON.parse(value), null, padding);
                        case "XML":
                            return formatXml(value, true, padding);
                        case "YAML":
                            return auxiliary.objectToYaml(auxiliary.yamlToObject(value), 0, padding);
                        default:
                            console.error("Unsupported formatting lang");
                            return -1;
                    }
                },

                minify: function(value, params) {
                    const lang = params.getFormatingLang();
                    switch (lang) {
                        case "JSON":
                            return JSON.stringify(JSON.parse(value));
                        case "XML":
                            return formatXml(value, false);
                        case "YAML":
                            // YAML minification isn't standard like JSON/XML.
                            // We return a "clean" block-style version (normalized, no comments).
                            return auxiliary.objectToYaml(auxiliary.yamlToObject(value), 0, "  ");
                        default:
                            console.error("Unsupported formatting lang");
                            return -1;
                    }
                },

                toUpperCase: (v) => v.toUpperCase(),
                toLowerCase: (v) => v.toLowerCase(),
                replicate: (v, p) => {
                    const mode = p ? p.getReplicateMode() : "simple";
                    if (mode === "simple") return v + v;

                    const template = v;
                    const placeholder = p.getReplicatePlaceholder();
                    let result = "";

                    if (mode === "range") {
                        const start = p.getReplicateRangeStart(), end = p.getReplicateRangeEnd();
                        const step = start > end ? -1 : 1;
                        for (let i = start; step > 0 ? i <= end : i >= end; i += step) {
                            result += template.replaceAll(placeholder, i);
                        }
                    } else {
                        p.getReplicateTemplateItems().forEach(item => {
                            result += template.replaceAll(placeholder, item);
                        });
                    }
                    return result;
                },

                sort: function(value, params) {
                    return params.isAscending()?
                        value.split("\n").sort().join("\n") :
                        value.split("\n").sort().reverse().join("\n");
                },

                sortObject: function (value, params) {
                    let unsortedObject = JSON.parse(value);
                    return JSON.stringify(sortObject(unsortedObject, false, !params.isAscending()), null, params.getPadding());
                },

                CTypeLang_Stringify: function(value) {
                    const lines = value.split("\n");
                    let result = "";
                    for(let i = 0; i < lines.length; i++) {
                        result += (i == 0? "": "+ ")
                        + "\"" + trs.CLikeLang_StringEscape(lines[i])
                        + (i == lines.length - 1? "\"": "\\n\"" + "\n");
                    }
                    return result;
                },

                CTypeLang_Unstringify: function(value) {
                    const lines = value.split(/\s*\n\s*\+\s*/);
                    let result = "";
                    for(let i = 0; i < lines.length; i++) {
                        if(lines[i].match(/^".*"$/) == null) {
                            warn("Could not unstringify. Make sure you have valid C language type strings.", 5000);
                            return value;
                        }
                        result += trs.CLikeLang_StringUnescape(lines[i].substr(1, lines[i].length - 2));
                    }
                    return result;
                },

                xmlToJson: function(value) {
                    return xmlToJsonAux(value);
                },

                replace: function(value) {
                    const replaceValue = getReplaceValue();
                    const replaceWith = getReplaceWith();
                    const replaceAll = getReplaceAll();
                    const caseSensitive = getReplaceCaseSensitive();

                    if(replaceValue == "") {
                        warn("Nothing to replace");
                        return -1;
                    }

                    let result = value;

                    if(isReplaceRegex()) {
                        let regex = null;
                        try {
                            regex = new RegExp(replaceValue, "m" + (caseSensitive == true? "": "i") + (replaceAll == true? "g": ""));
                        } catch(e) {
                            console.error(e);
                            error(e.message);
                            return -1;
                        }

                        result = value.replace(regex, replaceWith);

                        return result;
                        
                    } else {
                        if(caseSensitive == true) {
                            if(replaceAll == true) {
                                result = value.replaceAll(replaceValue, replaceWith);
                            } else {
                                result = value.replace(replaceValue, replaceWith);
                            }
                            if(result == value) {
                                info("'"+ replaceValue + "'" + " was not found.")
                                return -1;
                            }
                            return result;
                        } else {
                            if(replaceAll == true) {
                                let found = indexes(value.toLowerCase(), replaceValue.toLowerCase());
                                if(found.length == 0) {
                                    info("'"+ replaceValue + "'" + " was not found.")
                                    return -1;
                                }
                                let result = value;
                                found.reverse().forEach(foundIndex => result = result.substr(0, foundIndex) + replaceWith + result.substr(foundIndex + replaceValue.length));
                                return result;
                            } else {
                                let foundIndex = value.toLowerCase().indexOf(replaceValue.toLowerCase());
                                if(foundIndex == -1) {
                                    info("'"+ replaceValue + "'" + " was not found.")
                                    return -1;
                                }
                                
                                return value.substr(0, foundIndex) + replaceWith + value.substr(foundIndex + replaceValue.length);
                            }
                        }
                    }
                },

                compress: async function (text, params) {
                    const algorithm = params.compressAlgorithm();
                    const encoder = new TextEncoder();
                    const utf8Bytes = encoder.encode(text);
                    const compressedStream = new CompressionStream(algorithm);
                    const writer = compressedStream.writable.getWriter();
                    writer.write(utf8Bytes);
                    writer.close();
                    const compressedBytes = await collectStream(compressedStream.readable);
                    const base64String = btoa(String.fromCharCode(...new Uint8Array(compressedBytes)));
                    return base64String;
                },

                decompress: async function (base64String, params) {
                    const algorithm = params.compressAlgorithm();
                    const compressedBytes = Uint8Array.from(atob(base64String), c => c.charCodeAt(0));
                    const decompressedStream = new DecompressionStream(algorithm);
                    const writer = decompressedStream.writable.getWriter();
                    writer.write(compressedBytes);
                    writer.close();
                    const decompressedBytes = await collectStream(decompressedStream.readable);
                    const decoder = new TextDecoder();
                    const decompressedText = decoder.decode(decompressedBytes);
                    return decompressedText;
                },

                digest: async function (text, params) {
                    const algorithm = params.digestAlgorithm();
                    const outputFormat = params.digestOutputFormat();
                    
                    const msgUint8 = new TextEncoder().encode(text); // encode as (utf-8) Uint8Array
                    const hashBuffer = await window.crypto.subtle.digest(algorithm, msgUint8); // hash the message
                    const hashArray = Array.from(new Uint8Array(hashBuffer)); // convert buffer to byte array

                    if(outputFormat === "hex") {
                        return hashArray
                        .map((b) => b.toString(16).padStart(2, "0"))
                        .join(""); // convert bytes to hex string
                    } else if (outputFormat === "base64") {
                        return btoa(String.fromCharCode(...hashArray));
                    }
                }
                
 
                // TODO: add more transformers here

            };
        })();


        function copyToClipboard(value) {
            const toCopy = document.createElement("textarea");
            toCopy.style.width = 0;
            toCopy.style.height = 0;
            toCopy.value = value;
            document.body.appendChild(toCopy);

            /* Select the text field */
            toCopy.select();
            toCopy.setSelectionRange(0, value.length + 1); /*For mobile devices*/

            /* Copy the text inside the text field */
            document.execCommand("copy");

            document.body.removeChild(toCopy);

            info("Value " + (value.length < 100 ? value : "") + " copied to clipboard!");
        }

        function clearValue() {
            const valueTextArea = getValueElement();
            valueTextArea.value = "";
            valueTextArea.focus();
        }

        function copyValue() {
            const valueTextArea = getValueElement();
            copyToClipboard(valueTextArea.value);
            info("Value copied to clipboard!");
        }

        function cropToSelection() {
            const valueTextArea = getValueElement();
            valueTextArea.value = valueTextArea.value.substr(cursorPos.start, cursorPos.end - cursorPos.start);
            valueTextArea.focus();
        }

        function saveToFile() {
            const valueTextArea = getValueElement();
            const value = isSelectionMode()? valueTextArea.value.substr(cursorPos.start, cursorPos.end - cursorPos.start): valueTextArea.value;
            if(value.length == 0) {
                info("Nothing to save.");
                return;
            }
            const a = document.createElement("a");
            a.href = window.URL.createObjectURL(new Blob([value], {type: "text/plain"}));
            a.download = "file.txt";
            a.click();
        }

        let cursorPos = {
            start: -1,
            end: -1,
            line: -1,
            column: -1
        };
        
        function getCursorPos(input) {
            if ("selectionStart" in input && document.activeElement == input) {
                const text = input.value;
                const start = input.selectionStart;
                cursorPos.start = start;
                cursorPos.end = input.selectionEnd;
                
                cursorPos.line = text.substr(0, start).split("\n").length;
                cursorPos.column = start - text.lastIndexOf('\n', start - 1) - 1;
                return cursorPos;
            }
            else if (input.createTextRange) {
                const sel = document.selection.createRange();
                if (sel.parentElement() === input) {
                    var rng = input.createTextRange();
                    rng.moveToBookmark(sel.getBookmark());
                    for (var len = 0;
                        rng.compareEndPoints("EndToStart", rng) > 0;
                        rng.moveEnd("character", -1)) {
                        len++;
                    }
                    rng.setEndPoint("StartToStart", input.createTextRange());
                    for (var pos = { start: 0, end: len };
                        rng.compareEndPoints("EndToStart", rng) > 0;
                        rng.moveEnd("character", -1)) {
                        pos.start++;
                        pos.end++;
                    }

                    const text = input.value;
                    pos.line = text.substr(0, pos.start).split("\n").length;
                    pos.column = pos.start - text.lastIndexOf('\n', pos.start - 1) - 1;
                    cursorPos = pos;
                    return cursorPos;
                }
            }
            cursorPos = {
                start: -1,
                end: -1,
                line: -1,
                column: -1
            };
            return cursorPos;
        }

        const getVal = (id, prop = 'value') => document.getElementById(id)[prop];

        function formatWhitepacePadding() {
            return getVal("useTabs", "checked") ? '\t' : '  ';
        }

        function getFormattingLang() { return getVal("formattingLang"); }
        function xmlSafe() { return getVal("xmlSafe", "checked"); }
        function sortIsAscending() { return !getVal("sortDescending", "checked"); }
        function isReplaceRegex() { return getVal("replaceRegex", "checked"); }
        function getReplaceValue() { return getVal("replaceValue"); }

        function getReplaceWith() {
            let val = getVal("replaceWith");
            return getVal("replaceEscaped", "checked") ? trs.CLikeLang_StringUnescape(val) : val;
        }

        function getCompressAlgorithm() { return getVal("compressAlgorithm"); }
        function getDigestAlgorithm() { return getVal("digestAlgorithm"); }
        function getDigestOutputFormat() { return getVal("digestOutputFormat"); }
        function getReplaceAll() { return getVal("replaceAll", "checked"); }
        function getReplaceCaseSensitive() { return getVal("replaceCaseSensitive", "checked"); }
        function getReplaceEscaped() { return getVal("replaceEscaped", "checked"); }

        function getCol(value, start) {
            const text = value.value;
            let index = start;
            while (index > 0 && text[index - 1] !== '\n' && text[index - 1] !== '\r') {
                index--;
            }
            return start - index;
        }

        window.valueTouched = new Date();
        function fetchData() {
            if(document.activeElement == getValueElement()) {
                const valueTextArea = getValueElement();
                const pos = getCursorPos(valueTextArea);

                document.getElementById("start").innerHTML = pos.start;
                document.getElementById("end").innerHTML = pos.end;
                document.getElementById("selection").innerHTML = pos.end - pos.start;
                document.getElementById("length").innerHTML = valueTextArea.value.length;

                document.getElementById("line").innerHTML = pos.line;
                document.getElementById("col").innerHTML = pos.column;

                window.valueTouched = new Date();
            }
        }

        function detectFormatOrLanguage() {
            const valueTextArea = getValueElement();
            const value = valueTextArea.value;

            // Check for JSON (three-state return)
            const jsonCheckResult = auxiliary.isJson(value);
            if (jsonCheckResult.valid === true) {
                return { type: "JSON", valid: true, data: jsonCheckResult.data };
            } else if (typeof jsonCheckResult === 'object') {
                console.error("Malformed JSON detected: " + jsonCheckResult.message);
                return { type: "JSON", valid: false, error: jsonCheckResult };
            }

            // Check for XML (three-state return)
            const xmlCheckResult = auxiliary.isXml(value);
            if (xmlCheckResult === true) {
                return { type: "XML", valid: true };
            } else if (typeof xmlCheckResult === 'object') {
                console.error("Malformed XML detected: " + xmlCheckResult.message);
                return { type: "XML", valid: false, error: xmlCheckResult };
            }

            // Check for YAML (three-state return)
            if (auxiliary.isYaml(value) === true) {
                try {
                    const data = auxiliary.yamlToObject(value);
                    return { type: "YAML", valid: true, data: data };
                } catch (e) {
                    console.error("Malformed YAML detected: " + e.message);
                    return { type: "YAML", valid: false, error: e };
                }
            }
            
            // Check for Base64 (boolean return)
            if (auxiliary.isBase64(value) === true) {
                return { type: "Base64", valid: true };
            }
            
            // Check for Hex (boolean return)
            if (auxiliary.isHex(value) === true) {
                return { type: "Hex", valid: true };
            }

            // Format not detected
            return null;
        }

        function rndSpecialChanged(event) {
            if (event.target.checked == false) {
                document.getElementById('rndSpecialChars').setAttribute("disabled", "");
            } else {
                document.getElementById('rndSpecialChars').removeAttribute("disabled");
            }
        }

        let stopRndChangeEvent = false;

        function preventInvalidSpecialChars(event) {
            if (event.keyCode < 32) {
                return true;
            }
            const pattern = new RegExp(event.target.pattern);

            return pattern.test(event.key);
        }

        function preventInvalidRndLength(event) {
            if(parseInt(this.value) > parseInt(this.max) || parseInt(this.value) < parseInt(this.min)) {
                this.value = this.max;
            }
        }

        function adjustRndStringSlider(slider) {
            slider.style.backgroundSize = (slider.value - slider.min) * 100 / (slider.max - slider.min) + '% 100%';
        }

        function getRandomStringParams() {
            return {
                length: document.getElementById("rndStringLength").value,
                lower: document.getElementById("rndLower").checked,
                upper: document.getElementById("rndUpper").checked,
                digits: document.getElementById("rndDigits").checked,
                special: document.getElementById("rndSpecial").checked,
                specialChars: document.getElementById("rndSpecial").checked == true ? document.getElementById("rndSpecialChars").value : ""
            };
        }

        let messageId = null;
        function notify(text, type, delay) {
            const configs = {
                info:  { label: "&#8505;&nbsp;Info", bg: "aliceblue",      fg: "#7070A0" },
                warn:  { label: "&#9888;&nbsp;Warning", bg: "blanchedalmond", bg: "blanchedalmond", fg: "#806640" },
                error: { label: "&#9888;&nbsp;Error", bg: "coral",           fg: "#905050" }
            };
            const config = configs[type] || configs.info;
            const msg = document.getElementById("message");
            document.getElementById("messageType").innerHTML = config.label;
            document.getElementById("messageText").innerText = text;
            msg.style.background = config.bg;
            msg.style.color = config.fg;
            msg.style.display = "flex";
            const id = auxiliary.uuidv4();
            messageId = id;
            window.setTimeout(() => { if (id == messageId) msg.style.display = "none"; }, delay || 2000);
        }

        const info = (t, d) => notify(t, "info", d);
        const warn = (t, d) => notify(t, "warn", d);
        const error = (t, d) => notify(t, "error", d);

        function setWrap() {
            const valueElement = getValueElement();
            const wrap = !document.getElementById("cbWrap").checked;
            
            if (wrap) {
                valueElement.classList.remove("nowrap");
            } else {
                valueElement.classList.add("nowrap");
            }
        }

        function dropHandler(ev) {
            return;
            // TODO resume implementation
            console.log("File(s) dropped");

            // Prevent default behavior (Prevent file from being opened)
            ev.preventDefault();

            if (ev.dataTransfer.items) {
                // Use DataTransferItemList interface to access the file(s)
                [...ev.dataTransfer.items].forEach((item, i) => {
                // If dropped items aren't files, reject them
                if (item.kind === "file") {
                    const file = item.getAsFile();
                    console.log(`1 file[${i}].name = ${file.name}`);
                    debugger;


                    //reader = new FileReader();

                    //reader.readAsDataURL(file);
                }
                });
            } else {
                // Use DataTransfer interface to access the file(s)
                [...ev.dataTransfer.files].forEach((file, i) => {
                console.log(`2 file[${i}].name = ${file.name}`);
                debugger;
                });
            }
        }

        function selectReplicateTemplateItems() {
            const rawItems = document.getElementById("replicateTemplateItemsBuilder").value;

            let result = [];
            rawItems.split("\n").forEach(item => {
                if(item.trim().length > 0) {
                    result.push(item.trim());
                }
            });

            document.getElementById("replicateTemplateItems").value = result.join(",");
        }

        function fillReplicateTemplateItemsBuilder() {
            document.getElementById("replicateTemplateItemsBuilder").value =
                getReplicateTemplateItems().join("\n");
            
            document.querySelector(".overlay").style.display = "flex";
        }

        function getReplicateMode() {
            return document.getElementById("replicateMode").value;
        }

        function getReplicateRangeStart() {
            return parseInt(document.getElementById("replicateRangeStart").value);
        }
        function getReplicateRangeEnd() {
            return parseInt(document.getElementById("replicateRangeEnd").value);
        }
        
        function getReplicateTemplateItems() {
            return document.getElementById("replicateTemplateItems").value.split(",");
        }
        
        function getReplicatePlaceholder() {
            return document.getElementById("replicatePlaceholder").value.trim();
        }

        function selectReplicateMode() {
            const mode = getReplicateMode();

            if(mode === "simple") {
                document.getElementById("replicateParams").style.display = "none";
            } else {
                document.getElementById("replicateParams").style.display = "inherit";

                if(mode === "template") {
                    document.getElementById("replicateRange").style.display = "none";
                    document.getElementById("replicateTemplateItems").style.display = "inherit";
                    replicateTemplateItems
                } else {
                    document.getElementById("replicateRange").style.display = "inherit";
                    document.getElementById("replicateTemplateItems").style.display = "none";
                }
            }
        }

        function updateDetectedFormatDisplay(detected) {
            const detectedFormatDiv = document.getElementById("detectedFormatDiv");
            const formatIdentifier = document.getElementById("formatIdentifier");
            const formatValidity = document.getElementById("formatValidity");
            const objectTreeContainer = document.getElementById("objectTree");
            const formattingLangSelect = document.getElementById("formattingLang");

            if(detected == null) {
                detectedFormatDiv.style.display = "none";
                formatIdentifier.innerText = "";
                formatValidity.innerText = "";
                formattingLangSelect.value = "JSON";

                if(objectTreeContainer) {
                    objectTreeContainer.style.display = 'none';
                    objectTreeContainer.innerHTML = '';
                }
                return;
            }

            detectedFormatDiv.style.display = "block";
            formatIdentifier.innerText = detected.type;

            if(detected.valid === false) {
                formatIdentifier.classList.add("error-tag");
                formatIdentifier.classList.remove("success-tag");
                formatValidity.innerText = detected.error.message;
                formattingLangSelect.value = "JSON";

                if(objectTreeContainer) {
                    objectTreeContainer.style.display = 'none';
                    objectTreeContainer.innerHTML = '';
                }
            } else {
                formatIdentifier.classList.remove("error-tag");
                formatIdentifier.classList.add("success-tag");
                formatValidity.innerText = "";

                if (["JSON", "XML", "YAML"].includes(detected.type)) {
                    formattingLangSelect.value = detected.type;
                } else {
                    formattingLangSelect.value = "JSON";
                }

                if ((detected.type === "JSON" || detected.type === "YAML") && objectTreeContainer) {
                    objectTreeContainer.style.display = 'block';
                    createObjectTreeView(detected.data, "objectTree", detected.type);

                    if (detected.type === "YAML") {
                        const rawValue = getValueElement().value;
                        if (/(?:^|\s)[&*][a-zA-Z0-9_-]+/m.test(rawValue)) {
                            formatValidity.innerText = "Note: YAML anchors/aliases (&/*) detected but not supported (treated as strings).";
                        }
                    }
                } else {
                    if(objectTreeContainer) {
                        objectTreeContainer.style.display = 'none';
                        objectTreeContainer.innerHTML = '';
                    }
                }
            }
        }

        function applyValueToMain(value) {
            getValueElement().value = value;
            flashValue();
            fetchData();
            updateDetectedFormatDisplay(detectFormatOrLanguage());
        }

        /**
         * Renders a JavaScript object into a collapsible and expandable tree view.
         * @param {object} data The JavaScript object to render.
         * @param {string} containerElementId The ID of the container element to render the tree into.
         * @param {string} type The type of the object (e.g., "JSON").
         */
        function createObjectTreeView(data, containerElementId, type = "JSON") {
            const container = document.getElementById(containerElementId);
            if (!container) return;
            container.innerHTML = '';
            container.classList.add('object-tree-container');

            const copyToCb = (text, button) => {
                navigator.clipboard.writeText(text).then(() => {
                    const old = button.textContent;
                    button.textContent = 'Copied!';
                    setTimeout(() => button.textContent = old, 1500);
                });
            };

            const buildNode = (key, value, isRoot = false) => {
                const type = value === null ? 'null' : Array.isArray(value) ? 'array' : typeof value;
                const styleType = type === 'boolean' ? (value ? 'boolean-true' : 'boolean-false') : type;
                const isComplex = type === 'object' || type === 'array';
                const isEmpty = isComplex && (Array.isArray(value) ? !value.length : !Object.keys(value).length);
                const isExpandable = isComplex && !isEmpty;

                const toggle = el('span', { class: 'toggle' + (isExpandable ? '' : ' hidden-visibility'), textContent: isExpandable ? '' : '' });
                const btn = (text, title, onclick) => el('button', { class: 'button button-xsmall node-action-btn', textContent: text, title, on: { click: (e) => { e.stopPropagation(); onclick(e); } } });

                const childrenContainer = el('div', { class: 'children hidden-display' });
                let childrenBuilt = false;

                const row = el('div', { class: isExpandable ? 'header' : 'primitive-node', on: { click: () => {
                    if (!isExpandable) return;
                    const isExpanded = toggle.classList.toggle('expanded');
                    toggle.textContent = isExpanded ? '' : '';
                    childrenContainer.classList.toggle('hidden-display', !isExpanded);
                    if (isExpanded && !childrenBuilt) {
                        const entries = Array.isArray(value) ? Array.from(value.entries()) : Object.entries(value);
                        const CHUNK = 100;
                        let cur = 0;
                        const render = () => {
                            entries.slice(cur, cur + CHUNK).forEach(([k, v]) => childrenContainer.appendChild(buildNode(k, v)));
                            cur += CHUNK;
                            if (cur < entries.length) {
                                childrenContainer.appendChild(el('div', { class: 'node header load-more', textContent: `... Show more (${entries.length - cur} left)`, on: { click: (e) => { e.stopPropagation(); childrenContainer.lastChild.remove(); render(); } } }));
                            }
                        };
                        render();
                        childrenBuilt = true;
                    }
                }}}, 
                    toggle,
                    el('span', { class: `type-icon ${styleType}`, textContent: {object:'{}', array:'[]', string:'', number:'#', boolean:value?'':'', null:''}[type] || '' }),
                    el('span', { class: `key ${styleType}`, textContent: `${key}: ` }),
                    isComplex ? el('span', { class: 'preview', textContent: Array.isArray(value) ? `Array(${value.length})` : 'Object' }) : (() => {
                        const full = JSON.stringify(value), max = 1000, isLong = full.length > max;
                        const txt = el('span', { textContent: isLong ? full.slice(0, max) : full });
                        const ell = el('span', { class: 'ellipsis' + (isLong ? '' : ' hidden-display'), textContent: '...' });
                        const more = isLong ? el('span', { class: 'expand-btn', textContent: ' (Show more)', on: { click: (e) => {
                            e.stopPropagation();
                            const show = more.textContent === ' (Show more)';
                            txt.textContent = show ? full : full.slice(0, max);
                            ell.classList.toggle('hidden-display', show);
                            more.textContent = show ? ' (Show less)' : ' (Show more)';
                        }}}) : null;
                        return el('span', { class: `value ${styleType}` }, txt, ell, more);
                    })(),
                    el('div', { class: 'node-buttons' },
                        isComplex ? [
                            btn('Copy JSON', '', (e) => copyToCb(JSON.stringify(value, null, formatWhitepacePadding()), e.target)),
                            btn('Copy YAML', '', (e) => copyToCb(auxiliary.objectToYaml(value, 0, formatWhitepacePadding()), e.target)),
                            btn('Apply JSON', 'Replace main text', () => applyValueToMain(JSON.stringify(value, null, formatWhitepacePadding()))),
                            btn('Apply YAML', 'Replace main text', () => applyValueToMain(auxiliary.objectToYaml(value, 0, formatWhitepacePadding())))
                        ] : [
                            btn('Copy Value', '', (e) => copyToCb(typeof value === 'string' ? value : JSON.stringify(value), e.target)),
                            btn('Apply Value', 'Replace main text', () => applyValueToMain(typeof value === 'string' ? value : JSON.stringify(value)))
                        ]
                    )
                );

                return el('div', { class: 'node' + (isRoot ? ' root' : '') }, row, childrenContainer);
            };

            container.appendChild(el('div', { class: 'object-tree-title' },
                el('span', { textContent: 'Tree Viewer' }),
                el('span', { class: 'type-tag', textContent: type }),
                el('div', { class: 'tree-actions' },
                    el('button', { class: 'tree-action-btn', textContent: 'Expand All', on: { click: () => {
                        const exp = (p) => {
                            p.querySelectorAll('.header').forEach(h => {
                                if (!h.querySelector('.toggle').classList.contains('expanded')) h.click();
                                const children = h.closest('.node').querySelector('.children');
                                if (children) exp(children);
                            });
                        };
                        exp(container);
                    }}}),
                    el('button', { class: 'tree-action-btn', textContent: 'Collapse All', on: { click: () => {
                        Array.from(container.querySelectorAll('.header')).reverse().forEach(h => {
                            if (h.querySelector('.toggle').classList.contains('expanded')) h.click();
                        });
                    }}})
                )
            ));
            container.appendChild(buildNode('root', data, true));
        }

    </script>
    <!-- Object Tree View Styles -->
    <style>
        .object-tree-container {
            font-family: Menlo, Monaco, 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.5;
            background-color: #242424;
            color: silver;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #444;
            margin-top: 10px;
        }
        .node {
            margin-left: 2em;
            padding-left: 5px;
            border-left: 1px dotted #555;
        }
        .node.root {
            margin-left: 0;
            padding-left: 0;
            border-left: none;
        }
        .header, .primitive-node {
            display: flex;
            align-items: center;
            padding: 2px 4px;
            transition: background-color 0.1s ease;
            border-radius: 2px;
            min-width: 0; /* Allow flex children to shrink */
        }
        .header:hover, .primitive-node:hover {
            background-color: #3e3e3e;
        }
        .header {
            cursor: pointer;
        }
        .toggle {
            width: 1.5em;
            text-align: center;
            font-size: 0.8em;
            color: #aaa;
            user-select: none;
            flex-shrink: 0;
        }
        .toggle.hidden-visibility {
            visibility: hidden;
        }
        .type-icon {
            width: 1.8em;
            text-align: center;
            margin-right: 8px;
            font-weight: bold;
            font-size: 0.8em;
            flex-shrink: 0;
            user-select: none;
            background-color: rgba(255, 255, 255, 0.05);
            border-radius: 3px;
            line-height: 1.6;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .key {
            font-weight: bold;
            flex-shrink: 0;
            white-space: nowrap;
        }
        .value {
            margin-left: 0.5em;
            overflow-wrap: anywhere;
            word-break: break-all;
            min-width: 0;
            flex-grow: 1;
        }
        /* Type-specific colors */
        .object { color: #d2a8ff; }
        .array { color: #ffa657; }
        .string { color: #a5d6ff; }
        .number { color: #79c0ff; }
        .boolean-true { color: #56d364; }
        .boolean-false { color: #ff7b72; }
        .null { color: #6e7681; }

        .preview {
            margin-left: 0.5em;
            color: #8b949e;
            font-style: italic;
            flex-shrink: 0;
        }
        .children {
            display: block;
        }
        .children.hidden-display {
            display: none;
        }
        .node-buttons {
            display: flex;
            gap: 5px;
            margin-left: auto;
            flex-shrink: 0;
        }
        .node-action-btn {
            width: auto;
            visibility: hidden;
            white-space: nowrap;
        }
        .header:hover .node-action-btn, .primitive-node:hover .node-action-btn {
            visibility: visible;
        }

        .object-tree-title {
            display: flex;
            align-items: center;
            border-bottom: 1px solid #333;
            padding-bottom: 8px;
            margin-bottom: 10px;
            font-weight: bold;
            color: #808080;
            font-family: sans-serif;
            font-size: 0.9rem;
            position: sticky;
            top: 0;
            background-color: #242424;
            z-index: 10;
            padding-top: 5px;
        }

        .type-tag {
            background-color: #444;
            color: #ccc;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            margin-left: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tree-actions {
            margin-left: auto;
            display: flex;
            gap: 10px;
        }

        .tree-action-btn {
            background: none;
            border: 1px solid #444;
            color: #808080;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 2px 8px;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .tree-action-btn:hover {
            background-color: #444;
            color: #ccc;
            border-color: #555;
        }

        .ellipsis {
            color: orange;
            font-weight: bold;
            user-select: none;
        }

        .expand-btn {
            cursor: pointer;
            color: #d2a8ff;
            font-size: 0.9em;
            margin-left: 5px;
            user-select: none;
        }

        .load-more {
            color: #d2a8ff;
            cursor: pointer;
            padding: 5px;
        }

        .hidden-display {
            display: none !important;
        }
    </style>
</head>

<body>
    <textarea id="value" value="" placeholder="Text goes here..." autofocus ondrop="dropHandler(event);" spellcheck="false"></textarea>
    <div style="float: right; position: relative; font-size: small; margin-top: 0.2rem; display: grid; grid-template-columns: 1fr 1fr; column-gap: 0.5rem; row-gap: 0.1rem; text-align: end;" >
        <div>Line: <span id="line"></span></div><div>Column: <span id="col"></span></div>
        <div>Start: <span id="start"></span></div><div>End: <span id="end"></span></div>
        <div>Selection: <span id="selection"></span></div><div>Length: <span id="length"></span></div>
    </div>
    <div style="float: right; clear: right; position: relative; font-size: small; padding-top: 0.3rem; text-align: end; display: none" id="detectedFormatDiv">
        <span id="formatIdentifier" class="error-tag" style="display: block; float: right;"></span>
        <span id="formatValidity" style="color: orange; padding-top: 0.2rem; display: block; clear: right; max-width: 25rem;"></span>
    </div>

    <div>
        <div class="buttonGroup">
            <input type="button" value="URL Encode" data-trs="urlencode" /><br />
            <input type="button" value="URL Decode" data-trs="urldecode" />
            <hr/>
            <input type="button" value="HTML Encode" onclick="transform(trs.htmlencode2, {'xmlSafe': xmlSafe});" />
            <br />
            <label class="off-on">
                <input id="xmlSafe" type="checkbox" checked />
                <span class="off-on-slider round"></span>
            </label><label for="xmlSafe">XML safe?</label>
            <br />
            <input type="button" value="HTML Decode" data-trs="htmldecode" />
        </div>

        <div class="buttonGroup">
            <input type="button" value="Base64 Encode" data-trs="base64encode" /><br />
            <input type="button" value="Base64 Decode" data-trs="base64decode" />
            <hr/>
            <input type="button" value="HEX Encode" data-trs="hexencode" /><br />
            <input type="button" value="HEX Decode" data-trs="hexdecode" />
        </div>

        <div class="buttonGroup">
            <input type="button" value="String Escape" data-trs="CLikeLang_StringEscape" /><br />
            <input type="button" value="String Unescape" data-trs="CLikeLang_StringUnescape" />
            <hr/>
            <input type="button" value="Stringify" data-trs="CTypeLang_Stringify" /><br />
            <input type="button" value="Unstringify" data-trs="CTypeLang_Unstringify" />
        </div>

        <div class="buttonGroup">
            <input type="button" value="Pretty Print"
                onclick="transform(trs.prettyPrint, { 'getPadding': formatWhitepacePadding, 'getFormatingLang': getFormattingLang });"><br />
            <input type="button" value="Minify"
                onclick="transform(trs.minify, { 'getFormatingLang': getFormattingLang });"><br/>
                <hr/>
            <select id="formattingLang">
                <option selected value="JSON">JSON</option>
                <option value="XML">XML</option>
                <option value="YAML">YAML</option>
            </select><br/>
            <label class="switch">
                <input type="checkbox" id="useTabs">
                <span class="slider round slider-padding"></span>
            </label>
        </div>
        
        <div class="buttonGroup">
            <input type="button" value="Digest"
                onclick="transform(trs.digest, {'digestAlgorithm': getDigestAlgorithm, 'digestOutputFormat': getDigestOutputFormat });" /><br />
           
            <hr/>
            <select id="digestAlgorithm">
                <option selected value="SHA-256">SHA-256</option>
                <option value="SHA-1">SHA-1</option>
                <option value="SHA-384">SHA-384</option>
                <option value="SHA-512">SHA-512</option>
            </select>
            <br/>
            <select id="digestOutputFormat">
                <option selected value="hex">To HEX</option>
                <option value="base64">To Base64</option>
            </select>
        </div>

        <div class="buttonGroup">
            <input type="button" value="Compress"
                onclick="transform(trs.compress, {'compressAlgorithm': getCompressAlgorithm });" /><br />
            <input type="button" value="Decompress"
                onclick="transform(trs.decompress, {'compressAlgorithm': getCompressAlgorithm });" />
            <hr/>
            <select id="compressAlgorithm">
                <option selected value="deflate">Deflate</option>
                <option value="deflate-raw">Deflate Raw</option>
                <option value="gzip">GZip</option>
            </select>
        </div>

        <div class="buttonGroup">
            <input type="button" value="To UPPERCASE" data-trs="toUpperCase" /><br />
            <input type="button" value="To lowercase" data-trs="toLowerCase" />
        </div>

        <div class="buttonGroup">
            <input type="button" value="Replicate"
                onclick="transform(trs.replicate, {'getReplicateMode': getReplicateMode, 'getReplicatePlaceholder': getReplicatePlaceholder, 'getReplicateRangeStart': getReplicateRangeStart, 'getReplicateRangeEnd': getReplicateRangeEnd, 'getReplicateTemplateItems': getReplicateTemplateItems});" /><br/>

            <select id="replicateMode" onchange="selectReplicateMode()">
                <option value="simple">Simple</option>
                <option value="template">Template</option>
                <option value="range">Ranged</option>
            </select><br/>

            <div id="replicateParams" style="display: none;">
                <div id="replicateRange">
                    <input id="replicateRangeStart" type="number" value="1" min="0" />
                    <input id="replicateRangeEnd" type="number" value="10" min="0" style="margin-left: 58px" />
                </div>
                
                <input onfocus="fillReplicateTemplateItemsBuilder()" id="replicateTemplateItems" type="text" placeholder="Items" readonly />
                
                <br/>
                <br/>

                <small>Placeholder</small> <input id="replicatePlaceholder" type="text" value="##" style="width:88px" />
                <div class="overlay">
                    <div style="position: relative; width: 500px; height: 700px; background-color: #909090; margin: auto;">

                        <textarea id="replicateTemplateItemsBuilder" placeholder="items: one per line" style="height: 600px;" spellcheck="false"></textarea>
                
                        <div style="margin: auto;align-items: center;display: flex;height: 100px;width: fit-content;">
                            <button class="button" onclick="this.closest('.overlay').style.display='none'">Close</button>&nbsp;
                            <button class="button" onclick="this.closest('.overlay').style.display='none'; selectReplicateTemplateItems()">OK</button>
                        </div>
                        
                    </div>
                </div>
            </div>

            
        </div>
        <div class="buttonGroup">
            <input type="button" value="Sort lines"
                onclick="transform(trs.sort, {'isAscending': sortIsAscending });" /><br />
            <input type="button" value="Sort JSON"
                onclick="transform(trs.sortObject, {'isAscending': sortIsAscending, 'getPadding': formatWhitepacePadding });" />
            <br/>
            <label class="switch">
                <input type="checkbox" id="sortDescending">
                <span class="slider round slider-sort"></span>
            </label>
        </div>
    </div>
    <hr />
    <div>
        <div class="buttonGroup">
            <input type="button" value="Copy" onclick="copyValue();" /><br/>
            <input type="button" value="Clear" onclick="clearValue();" /><br/>
            <input type="button" value="Crop" onclick="cropToSelection();" /><br/>
            <input type="button" value="Save as..." onclick="saveToFile();" />
        </div>
        <div class="buttonGroup">
            <input type="button" value="New GUID" data-gens="generateGuid" /><br/>
            <input type="button" value="ISO DateTime" data-gens="isoDateTime" /><br/>
            <input type="button" value="Epoch" data-gens="epoch" />
        </div>

        <div class="buttonGroup settingsGroup">
            <label>Random text</label><br />
            <input id="rndStringLength" type="range" min="1" max="256" value="10"
                style="width: 350px;"
                oninput="adjustRndStringSlider(this); stopRndChangeEvent = true; rndStringLengthNumberInput.value = value; generate(gens.randomString, { loadParams: getRandomStringParams });"
                onclick="adjustRndStringSlider(this); if(stopRndChangeEvent == true) { stopRndChangeEvent = false; } else { generate(gens.randomString, { loadParams: getRandomStringParams }); }" />
            <input id="rndStringLengthNumberInput" type="number" min="1" max="256" value="10" style="width: 50px;" onchange="rndStringLength.value = value; rndStringLength.click()"/><br />
            <label class="off-on">
                <input id="rndLower" type="checkbox" checked
                onchange="generate(gens.randomString, { loadParams: getRandomStringParams });"/>
                <span class="off-on-slider round"></span>
            </label><label for="rndLower">Alpha lowercase</label><br />

            <label class="off-on">
                <input id="rndUpper" type="checkbox" checked
                onchange="generate(gens.randomString, { loadParams: getRandomStringParams });"/>
                <span class="off-on-slider round"></span>
            </label><label for="rndUpper">Alpha UPPERCASE</label><br />
            
            <label class="off-on">
                <input id="rndDigits" type="checkbox" checked
                onchange="generate(gens.randomString, { loadParams: getRandomStringParams });"/>
                <span class="off-on-slider round"></span>
            </label><label for="rndDigits">Digits</label><br />

            <label class="off-on">
                <input id="rndSpecial" type="checkbox"
                onchange="rndSpecialChanged(event); generate(gens.randomString, { loadParams: getRandomStringParams });"/>
                <span class="off-on-slider round"></span>
            </label><label for="rndSpecial">Special</label>&nbsp;
            <input id="rndSpecialChars" type="text" value="[\]^_!&quot;#$%&amp;'()*+,-./`:;&lt;=&gt;?{|}~"
                pattern="[\[\\\]\^_!&quot;#\$%&amp;'\(\)\*\+,-\.\/`:;&lt;=&gt;\?\{\|\}~]+" size="31"
                placeholder="Special chars" disabled
                onchange="generate(gens.randomString, { loadParams: getRandomStringParams });" />
        </div>

        <div class="buttonGroup">
            <input type="text" id="replaceValue" placeholder="To replace..." style="margin: 4px 2px;" /><br/>
            <input type="text" id="replaceWith" placeholder="Replace with..." style="margin: 4px 2px;" /><br/>
            <input type="button" value="Replace" data-trs="replace" /><br/>
            <label class="off-on">
                <input id="replaceAll" type="checkbox" checked />
                <span class="off-on-slider round"></span>
            </label><label for="replaceAll">Replace all</label><br/>
            <label class="off-on">
                <input id="replaceRegex" type="checkbox" />
                <span class="off-on-slider round"></span>
            </label><label for="replaceRegex">Use RegEx</label><br/>
            <label class="off-on">
                <input id="replaceCaseSensitive" type="checkbox" checked />
                <span class="off-on-slider round"></span>
            </label><label for="replaceCaseSensitive">Case sensitive</label><br/>
            <label class="off-on">
                <input id="replaceEscaped" type="checkbox" />
                <span class="off-on-slider round"></span>
            </label><label for="replaceEscaped">Replace escaped</label>
        </div>
    </div>
    <hr />

    <h4>Mode</h4>
    <label class="switch">
        <input type="checkbox" id="cbCopy">
        <span class="slider round slider-copy"></span>
    </label>
    
    <label class="switch" style="display: none;">
        <input type="checkbox" id="cbSelection">
        <span class="slider round slider-selection"></span>
    </label>
    
    <label class="switch">
        <input type="checkbox" id="cbWrap" onchange="setWrap()">
        <span class="slider round slider-wrap"></span>
    </label>

    <div class="buttonGroup">
        <select id="selectionMode" class="button round">
            <option value="allText">All Text</option>
            <option value="selection">Selection</option>
            <option value="lines">Lines</option>
        </select>
    </div>

    <div id="message"
        style="position: fixed; left: 10px;bottom: 10px;right: 10px;z-index: 1000;background: blanchedalmond;color: #909090;display: none;align-items: center;">
        <strong id="messageType" style="padding: 10px;float: left;">Info</strong>
        <span id="messageText" style="padding: 3px;">.</span>
    </div>

    <div class="sidebar">
        <div onclick="this.parentElement.classList.toggle('sidebarExpanded');" style="writing-mode: vertical-rl;user-select: none;border-right: 20px solid #ccc;border-bottom: 15px solid transparent;border-top: 15px solid transparent;
        width: 0px;height: 62px;" onclick=""><span style="position: absolute;right: 0px;letter-spacing: 2px;color: black;">History</span></div>

        <div id="historyItems" class="sidebarBody">
        </div>
        <!-- ...Preview... TODO [Set] [Insert] [Remove] -->
    </div>
    
    <div id="objectTree" style="display: none;"></div>
    
</body>

</html>
